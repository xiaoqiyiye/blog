<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Spring Mvc on Xiaoqiyiye</title>
        <link>http://www.xiaoqiyiye.com/tags/spring-mvc/</link>
        <language>zh-CN</language>
        <author>xiaoqiyiye</author>
        <rights>Copyright (c) 2015-2016, xiaoqiyiye all rights reserved.</rights>
        <updated>Sat, 24 Oct 2015 20:20:51 &#43;0800</updated>
        
        <item>
            <title>SpringMVC源码分析(3) HandlerMapping分析</title>
            <link>http://www.xiaoqiyiye.com/2015/10/22/spring/handlermapping</link>
            <pubDate>Sat, 24 Oct 2015 20:20:51 &#43;0800</pubDate>
            <author>CoderZh</author>
            <guid>http://www.xiaoqiyiye.com/2015/10/22/spring/handlermapping</guid>
            <description>

&lt;hr /&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在前面的篇章中我们已经提及过HandlerMapping接口，HandlerMapping接口提供的方法很简单，就是创建HandlerExecutorChain对象。而在HandlerExecutorChain对象中包含了handler对象和拦截器链对象。所以，我们在分析HandlerMapping过程中，也主要围绕这两点分析。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
由于HandlerMapping提供了最基本的抽象实现AbstractHandlerMapping，所以我们从AbstractHandlerMapping开始分析。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-abstracthandlermapping-分析&#34;&gt;1.AbstractHandlerMapping 分析&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
关于AbstractHandlerMapping的分析，分为以下三个步骤：
1. 属性域说明
2. 获取拦截器
3. 创建HandlerExecutorChain对象&lt;/p&gt;

&lt;h4 id=&#34;1-1-属性域说明&#34;&gt;1.1 属性域说明&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// 配置默认的handler对象，在没有获取到handler的情况下使用
private Object defaultHandler;

// request请求路径解析辅助类
private UrlPathHelper urlPathHelper = new UrlPathHelper();

// 请求路径匹配辅助类，用于匹配哪些路径可以被MappedInterceptor来拦截处理
private PathMatcher pathMatcher = new AntPathMatcher();

// 子类或配置文件可以配置拦截器，这里的Object类型为：
// HandlerInterceptor, WebRequestInterceptor 和 MappedInterceptor
private final List&amp;lt;Object&amp;gt; interceptors = new ArrayList&amp;lt;Object&amp;gt;();

// 请求真正被适配到的拦截器(包含了HandlerInterceptor, WebRequestInterceptor)
private final List&amp;lt;HandlerInterceptor&amp;gt; adaptedInterceptors = new ArrayList&amp;lt;HandlerInterceptor&amp;gt;();

// 需要进行路径匹配的MappingInterceptor
private final List&amp;lt;MappedInterceptor&amp;gt; mappedInterceptors = new ArrayList&amp;lt;MappedInterceptor&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-2-获取拦截器&#34;&gt;1.2 获取拦截器&lt;/h4&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
由于AbstractHandlerMapping继承了WebApplicationObjectSupport类，所以在Spring容器启动完成后会调用initApplicationContext()方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void initApplicationContext() throws BeansException {
    
    // 钩子方法，由子类重写，子类可以添加新的拦截器，
    // interceptors是由配置文件设置的，在Bean注入时调用setInterceptors(Object[] interceptors)注入。
	extendInterceptors(this.interceptors);
	
	// 检测容器中注入的MappedInterceptor，并添加到mappedInterceptors中。
	detectMappedInterceptors(this.mappedInterceptors);
	
	//初始化拦截器，也就对interceptors中的拦截器分类存放，
	// MappedInterceptor拦截器存放到mappedInterceptors中去，
	// HandlerInterceptor、WebRequestInterceptor拦截器存放到adaptedInterceptors中去。
	initInterceptors();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
下面是initInterceptors()的具体实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void initInterceptors() {
	if (!this.interceptors.isEmpty()) {
		for (int i = 0; i &amp;lt; this.interceptors.size(); i++) {
			Object interceptor = this.interceptors.get(i);
			if (interceptor == null) {
				throw new IllegalArgumentException();
			}
			// 存在到mappedInterceptors
			if (interceptor instanceof MappedInterceptor) {
				mappedInterceptors.add((MappedInterceptor) interceptor);
			}
			// 存放到adaptedInterceptors
			else {
				adaptedInterceptors.add(adaptInterceptor(interceptor));
			}
		}
	}
}
protected HandlerInterceptor adaptInterceptor(Object interceptor) {
	if (interceptor instanceof HandlerInterceptor) {
		return (HandlerInterceptor) interceptor;
	}
	// WebRequestInterceptor接口会被适配成HandlerInterceptor接口
	else if (interceptor instanceof WebRequestInterceptor) {
		return new WebRequestHandlerInterceptorAdapter((WebRequestInterceptor) interceptor);
	}
	else {
		throw new IllegalArgumentException(&amp;quot;Interceptor type not supported: &amp;quot; + interceptor.getClass().getName());
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-3-创建handlerexecutorchain对象&#34;&gt;1.3 创建HandlerExecutorChain对象&lt;/h4&gt;

&lt;p&gt;很清楚，创建HandlerExecutorChain对象是接口方法 HandlerExecutionChain getHandler(HttpServletRequest request)，下面直接分析代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
    // 这是一个抽象方法，具体的handler对象，子类去提供，因为抽象类并不知道是请求需要哪种handler
	Object handler = getHandlerInternal(request);
	// 如果没有获取到，则获取默认配置的handler
	if (handler == null) {
		handler = getDefaultHandler();
	}
	// 如果没有默认配置，则返回null
	if (handler == null) {
		return null;
	}
	// 如果handler是String类型，则当作beanName从容器器获取
	if (handler instanceof String) {
		String handlerName = (String) handler;
		handler = getApplicationContext().getBean(handlerName);
	}
	// 返回HandlerExecutionChain对象
	return getHandlerExecutionChain(handler, request);
}

protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {
    // 如果handler本身是HandlerExecutionChain类型则不用创建，
    // 否则创建一个HandlerExecutionChain对象并设置handler
	HandlerExecutionChain chain =
		(handler instanceof HandlerExecutionChain) ?
			(HandlerExecutionChain) handler : new HandlerExecutionChain(handler);
    
    // 设置拦截器
	chain.addInterceptors(getAdaptedInterceptors());

    // 根据请求路径，匹配哪些MappedInterceptor需要被拦截
	String lookupPath = urlPathHelper.getLookupPathForRequest(request);
	for (MappedInterceptor mappedInterceptor : mappedInterceptors) {
		if (mappedInterceptor.matches(lookupPath, pathMatcher)) {
			chain.addInterceptor(mappedInterceptor.getInterceptor());
		}
	}
    
    // 返回最终的HandlerExecutionChain对象
	return chain;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
上面通过三个方面分析了AbstractHandlerMapping，我们明白了拦截器是怎么获取的，我们也明白了HandlerExecutionChain的创建过程。AbstractHandlerMapping抽象类几乎做完了HandlerMapping接口的所有事情，只是handler对象的获取留给了子类去自由发挥。接下来，我们需要看看子类都是如何创建handler对象的&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
我们知道如果在配置文件中没有配置HandlerMapping，那么，SpringMVC会根据DispatcherServlet.properties中的配置来获取HandlerMapping的实现类。在DispatcherServlet.properties中配置了两个HandlerMapping实现类BeanNameUrlHandlerMapping和DefaultAnnotationHandlerMapping。接下来我们根据这两个类，来讲解handler的获取。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
BeanNameUrlHandlerMapping和DefaultAnnotationHandlerMapping都是基于URL的HandlerMapping，而且继承关系都是： AbstractDetectingUrlHandlerMapping &amp;ndash;&amp;gt; AbstractUrlHandlerMapping。 所以我们接下来分析基于URL的HandlerMapping。&lt;/p&gt;

&lt;h3 id=&#34;2-abstracturlhandlermapping分析&#34;&gt;2.AbstractUrlHandlerMapping分析&lt;/h3&gt;

&lt;h4 id=&#34;2-1-基于url匹配handler的过程&#34;&gt;2.1 基于URL匹配handler的过程&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;protected Object getHandlerInternal(HttpServletRequest request) throws Exception {
    // 获取请求路径
	String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);
	// 查找handler对象
	Object handler = lookupHandler(lookupPath, request);
	if (handler == null) {
		Object rawHandler = null;
		// 处理根路径，获取配置的rootHandler
		if (&amp;quot;/&amp;quot;.equals(lookupPath)) {
			rawHandler = getRootHandler();
		}
		if (rawHandler == null) {
			rawHandler = getDefaultHandler();
		}
		if (rawHandler != null) {
		    // 如果是String类型，则从容器中根据beanName获取
			if (rawHandler instanceof String) {
				String handlerName = (String) rawHandler;
				rawHandler = getApplicationContext().getBean(handlerName);
			}
			// 钩子方法子类去校验
			validateHandler(rawHandler, request);
			// 使用配置的rawHandler，来创建HandlerExecutionChain，把HandlerExecutionChain当作handler
			handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, null);
		}
	}
	// 返回handler
	return handler;
}

protected Object lookupHandler(String urlPath, HttpServletRequest request) throws Exception {
	// 直接使用路径获取handler，那么，handlerMap中的数据是怎么来的？ 后面再分析。
	Object handler = this.handlerMap.get(urlPath);
	if (handler != null) {
	    // 如果是String类型，则从容器中根据beanName获取
		if (handler instanceof String) {
			String handlerName = (String) handler;
			handler = getApplicationContext().getBean(handlerName);
		}
		// 钩子方法子类去校验
		validateHandler(handler, request);
		// 使用配置的rawHandler，来创建HandlerExecutionChain，把HandlerExecutionChain当作handler
		return buildPathExposingHandler(handler, urlPath, urlPath, null);
	}
    // 模糊匹配代码省略...
	// 如果最终没有匹配到，则放回null
	return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-2-handler注册&#34;&gt;2.2 handler注册&lt;/h4&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在上面分析过程中，我们不禁会问handlerMap中数据是怎么来的呢？ 这个问题也就是我们需要讲解的handler注册。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {
	for (String urlPath : urlPaths) {
		registerHandler(urlPath, beanName);
	}
}

protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {

	Object resolvedHandler = handler;
	
	// 是否设置懒加载
	if (!this.lazyInitHandlers &amp;amp;&amp;amp; handler instanceof String) {
		String handlerName = (String) handler;
		if (getApplicationContext().isSingleton(handlerName)) {
			resolvedHandler = getApplicationContext().getBean(handlerName);
		}
	}

    // 如果可以直接获取到，则判断和传入的resolvedHandler是否一致
	Object mappedHandler = this.handlerMap.get(urlPath);
	if (mappedHandler != null) {
		if (mappedHandler != resolvedHandler) {
			throw new IllegalStateException();
		}
	}
	else {
	    // 设置rootlHandler和defaultHandler
		if (urlPath.equals(&amp;quot;/&amp;quot;)) {
			setRootHandler(resolvedHandler);
		}
		else if (urlPath.equals(&amp;quot;/*&amp;quot;)) {
			setDefaultHandler(resolvedHandler);
		}
		else {
		    // 存放到handlerMap中
			this.handlerMap.put(urlPath, resolvedHandler);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在AbstractUrlHandlerMapping中，并没有调用registerHandler()方法，也就是说，只是提供了方法。而方法修饰符为protected，所以注册handler肯定是在子类进行的。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
AbstractUrlHandlerMapping的实现很简单，可以总结为以下两点：
1. 根据请求路径urlPath从handlerMap中获取handler，首先直接匹配，然后模糊匹配。
2. 提供注册handler的方法registerHandler()供子类来注册handler，存放到handlerMap中去。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
接下来可以分析AbstractDetectingUrlHandlerMapping了，从名称上我们就可以看出，这个抽象类是用来检测获取Url的。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;3-abstractdetectingurlhandlermapping分析&#34;&gt;3.AbstractDetectingUrlHandlerMapping分析&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
AbstractDetectingUrlHandlerMapping注册handler是通过重写initApplicationContext()来进行的，在Spring容器启动好后会调用detectHandlers()方法，AbstractDetectingUrlHandlerMapping就开始检测所有的Bean，并获取URL。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void detectHandlers() throws BeansException {
	// 获取容器中所有beanNames(配置detectHandlersInAncestorContexts可以从父容器检测，默认为false)
	String[] beanNames = (this.detectHandlersInAncestorContexts ?
			BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :
			getApplicationContext().getBeanNamesForType(Object.class));

	for (String beanName : beanNames) {
	    // 检测每一个beanName中的所有url(抽象方法，子类去实现如何查找urls)
		String[] urls = determineUrlsForHandler(beanName);
		if (!ObjectUtils.isEmpty(urls)) {
			// 注册handler
			registerHandler(urls, beanName);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
AbstractDetectingUrlHandlerMapping调用了registerHandler()来注册handler，最终都存放到AbstractUrlHandlerMapping#handlerMap中去。剩下的事情就是子类如何实现抽象方法determineUrlsForHandler(beanName)了。&lt;/p&gt;

&lt;h3 id=&#34;4-beannameurlhandlermapping分析&#34;&gt;4. BeanNameUrlHandlerMapping分析&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
BeanNameUrlHandlerMapping是基于beanName来获取Url，beanName必须以/开头。代码很简单，直接看代码了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected String[] determineUrlsForHandler(String beanName) {
	List&amp;lt;String&amp;gt; urls = new ArrayList&amp;lt;String&amp;gt;();
	// beanName需要以/开头
	if (beanName.startsWith(&amp;quot;/&amp;quot;)) {
		urls.add(beanName);
	}
	// 获取该beanName的别名，别名也需要以/开头
	String[] aliases = getApplicationContext().getAliases(beanName);
	for (String alias : aliases) {
		if (alias.startsWith(&amp;quot;/&amp;quot;)) {
			urls.add(alias);
		}
	}
	// 把匹配的路径全部返回
	return StringUtils.toStringArray(urls);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-defaultannotationhandlermapping分析&#34;&gt;4. DefaultAnnotationHandlerMapping分析&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
虽然DefaultAnnotationHandlerMapping在3.2版本以后就设置成了@Deprecated，也就是不建议使用这个了(RequestMappingHandlerMapping代替了它)。但我现在使用的4.0.2版本中DispatcherServlet.properties默认提供的还是DefaultAnnotationHandlerMapping，所以在我们不主动切换HandlerMapping的大多数情况下，我们还是会使用DefaultAnnotationHandlerMapping。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
DefaultAnnotationHandlerMapping的功能是从配置了@Controller、@RequestMapping的类中回去请求url。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected String[] determineUrlsForHandler(String beanName) {
	ApplicationContext context = getApplicationContext();
	Class&amp;lt;?&amp;gt; handlerType = context.getType(beanName);
	// 获取类型注解@RequestMapping
	RequestMapping mapping = context.findAnnotationOnBean(beanName, RequestMapping.class);
	if (mapping != null) {
		// 缓存类型上的@RequestMapping注解
		this.cachedMappings.put(handlerType, mapping);
		Set&amp;lt;String&amp;gt; urls = new LinkedHashSet&amp;lt;String&amp;gt;();
		// 获取@RequestMapping value值
		String[] typeLevelPatterns = mapping.value();
		if (typeLevelPatterns.length &amp;gt; 0) {
			// 获取方法上的@RequestMapping
			String[] methodLevelPatterns = determineUrlsForHandlerMethods(handlerType, true);
			// 结合类型上的@RequestMapping路径和方法上的@RequestMapping路径
			for (String typeLevelPattern : typeLevelPatterns) {
			    // 类型上@RequestMapping value值可以不用/开头，这里会检测
				if (!typeLevelPattern.startsWith(&amp;quot;/&amp;quot;)) {
					typeLevelPattern = &amp;quot;/&amp;quot; + typeLevelPattern;
				}
				// 方法上是否有空值的@RequestMapping
				boolean hasEmptyMethodLevelMappings = false;
				for (String methodLevelPattern : methodLevelPatterns) {
					if (methodLevelPattern == null) {
						hasEmptyMethodLevelMappings = true;
					}
					else {
					    // 获取结合后的url
						String combinedPattern = getPathMatcher().combine(typeLevelPattern, methodLevelPattern);
						addUrlsForPath(urls, combinedPattern);
					}
				}
				// 直接使用类型上的@RequestMapping，但需要时Controller对象类型
				if (hasEmptyMethodLevelMappings ||
						org.springframework.web.servlet.mvc.Controller.class.isAssignableFrom(handlerType)) {
					addUrlsForPath(urls, typeLevelPattern);
				}
			}
			return StringUtils.toStringArray(urls);
		}
		else {
			// 获取方法上的@RequestMapping
			return determineUrlsForHandlerMethods(handlerType, false);
		}
	}
	else if (AnnotationUtils.findAnnotation(handlerType, Controller.class) != null) {
		// 检测@Controller中的@RequestMapping
		return determineUrlsForHandlerMethods(handlerType, false);
	}
	else {
		return null;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
上面的方法有点复杂，就上面的方法我们归纳一下：
1. 检测类@RequestMapping和@Controller，@RequestMapping优先。如果存在@RequestMapping，则不会检测@Controller。
2. 如果类@RequestMapping存在，则和方法@RequestMapping组合在一起。如果存在方法@RequestMapping存在没有设置value，则以类@RequestMapping路径设置。
3. 如果没有类@RequestMapping，则检测类@Controller。注意@Controller(value=&amp;ldquo;name&amp;rdquo;)，@Controller中设置的value并不会影响请求url。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
下面我们在看看方法上的@RequestMapping是如何解析的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected String[] determineUrlsForHandlerMethods(Class&amp;lt;?&amp;gt; handlerType, final boolean hasTypeLevelMapping) {
    // 这是一个空方法，返回null，提供给子类自定义
	String[] subclassResult = determineUrlsForHandlerMethods(handlerType);
	if (subclassResult != null) {
		return subclassResult;
	}

	final Set&amp;lt;String&amp;gt; urls = new LinkedHashSet&amp;lt;String&amp;gt;();
	Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; handlerTypes = new LinkedHashSet&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;();
	// 添加handler以及所有接口
	handlerTypes.add(handlerType);
	handlerTypes.addAll(Arrays.asList(handlerType.getInterfaces()));
	// 遍历handler及其接口方法
	for (Class&amp;lt;?&amp;gt; currentHandlerType : handlerTypes) {
	    // 递归调用类以及父类方法（接口及父接口），排除bridge方法(编译器生成的方法)和Object方法
		ReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() {
			@Override
			public void doWith(Method method) {
			    // 获取方法@RequestMapping
				RequestMapping mapping = AnnotationUtils.findAnnotation(method, RequestMapping.class);
				if (mapping != null) {
				    // 获取路径值
					String[] mappedPatterns = mapping.value();
					if (mappedPatterns.length &amp;gt; 0) {
						for (String mappedPattern : mappedPatterns) {
						    //如果存在类@RequestMapping，则方法@RequestMapping必须以/开头
							if (!hasTypeLevelMapping &amp;amp;&amp;amp; !mappedPattern.startsWith(&amp;quot;/&amp;quot;)) {
								mappedPattern = &amp;quot;/&amp;quot; + mappedPattern;
							}
							addUrlsForPath(urls, mappedPattern);
						}
					}
					// 添加null
					else if (hasTypeLevelMapping) {
						urls.add(null);
					}
				}
			}
		}, ReflectionUtils.USER_DECLARED_METHODS);
	}
	return StringUtils.toStringArray(urls);
}	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
关于方法@RequestMapping我们也总结一下：
1. handler类，父类，接口，父接口中所有设置有@RequestMapping注解的方法都会处理。
2. 如果有类@RequestMapping，则方法@RequestMapping设置value时，必须以/开头，否则添加到路径集合中。如果是@Controller，则方法@RequestMapping可以不用/开头设置value。&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
1. HandlerMapping接口的功能是用来创建HandlerExecutionChain对象。而在创建过程中需要获取hander对象和拦截器。
2. 拦截器的获取是通过属性interceptors在配置文件中注入的。
3. handler对象的获取是根据请求url，从handlerMap中匹配。
4. handlerMap中的数据，是在Spring容器启动完成后进行设置。设置方式由子类完成。
5. 明白了BeanNameUrlHandlerMapping的设置。
6. 明白了@Controller、@RequestMapping注解配置的url是如何被读取的。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>SpringMVC源码分析(2) DispatchServlet请求分发</title>
            <link>http://www.xiaoqiyiye.com/2015/10/22/spring/</link>
            <pubDate>Thu, 22 Oct 2015 22:20:51 &#43;0800</pubDate>
            <author>CoderZh</author>
            <guid>http://www.xiaoqiyiye.com/2015/10/22/spring/</guid>
            <description>

&lt;hr /&gt;

&lt;h3 id=&#34;dispatchservlet请求分发&#34;&gt;DispatchServlet请求分发&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在上一篇中我们分析了DispatchServlet的启动过程，这篇中我们将要分析DispatchServlet的请求分发过程，也就是SpringMVC的工作原理。在分析代码之前，我们先了解一下SpringMVC的工作原理，如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/fxHZEhw.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;客户端发出请求给web服务器，web服务器对http请求进行解析，如果匹配DispatcherServlet的请求映射路径（在web.xml中指定），web容器将请求转交给DispatcherServlet。&lt;/li&gt;
&lt;li&gt;DipatcherServlet接收到这个请求之后，根据HandlerMapping的配置，找到处理请求的处理器（Handler），处理器对象是包装在HandlerExecutorChain中的。&lt;/li&gt;
&lt;li&gt;DispatcherServlet根据处理器去匹配到HandlerAdapter。&lt;/li&gt;
&lt;li&gt;DispatcherServlet根据HandlerMapping找到对应的Handler,将处理权交给Handler（Handler将具体的处理进行封装），再由具体的HandlerAdapter对Handler进行具体的调用。&lt;/li&gt;
&lt;li&gt;Handler对数据处理完成以后将返回一个ModelAndView()对象给DispatcherServlet。&lt;/li&gt;
&lt;li&gt;Handler返回的ModelAndView()只是一个逻辑视图并不是一个真实的视图，DispatcherSevlet通过ViewResolver将逻辑视图转化为真正的视图View。&lt;/li&gt;
&lt;li&gt;Dispatcher通过model解析出ModelAndView()中的参数进行解析最终展现出完整的view并返回给客户端。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;1-dispatchservlet请求入口&#34;&gt;1. DispatchServlet请求入口&lt;/h5&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
前面说过了，DispatchServlet是HttpServlet的子类，所以请求入口肯定是doService(request, response)方法。在doService(request, response)中将一些特殊的对象设置到request中，包括了webApplicationContext对象，然后调用doDispatch(request, response)做请求的分发。这个方法很简单，大致的看一下就OK了，在DispatcherServlet中最重要的方法是doDispatch(request, response)这个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {

    // 添加一些特殊的属性对象
	request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
	request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);
	request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
	request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());

	...省略一些代码

	try {
        //这个方法最重要，这是SpringMVC的核心，如何去处理请求分发？
		doDispatch(request, response);
	}
	finally {
		...省略一些代码
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
接下来，看看最重要的doDispatch(request, response)，这个方法是SpringMVC的中心调度器，负责处理交互各个对象。在这个方法中，我们要弄明白执行的主要步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;获取HandlerExecutorChain对象&lt;/li&gt;
&lt;li&gt;获取HandlerAdapter对象&lt;/li&gt;
&lt;li&gt;调用拦截器前置处理方法HandlerInterceptor#preHandle(&amp;hellip;)&lt;/li&gt;
&lt;li&gt;调用HandlerAdapter#handle(processedRequest, response, handler)，返回ModelAndView&lt;/li&gt;
&lt;li&gt;调用拦截器后置处理方法HandlerInterceptor#postHandle(&amp;hellip;)&lt;/li&gt;
&lt;li&gt;处理ModelAndView&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
	HttpServletRequest processedRequest = request;

	HandlerExecutionChain mappedHandler = null;
	boolean multipartRequestParsed = false;

	WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

	try {
		ModelAndView mv = null;
		Exception dispatchException = null;

		try {
		    // 判断是否是文件上传请求
			processedRequest = checkMultipart(request);
			multipartRequestParsed = processedRequest != request;

            // 控制器执行链对象HandlerExecutionChain，
            // 这个对象包含了处理器handler和拦截器集合interceptors，
			// SpringMVC拦截器的处理都是在这里面定义的。
            // HandlerExecutionChain对象由HandlerMapping接口来创建。
			mappedHandler = getHandler(processedRequest);
			if (mappedHandler == null || mappedHandler.getHandler() == null) {
				noHandlerFound(processedRequest, response);
				return;
			}

			// 通过hander去匹配一个处理handler操作的适配器HandlerAdapter对象
			HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

            // 调用拦截器链前置处理方法，如果拦截器链上返回了false，则请求结束。
			if (!mappedHandler.applyPreHandle(processedRequest, response)) {
				return;
			}

			try {
				// 由HandlerAdapter对象去真正调用处理器，
				// Controller里的方法就是在这里调用的，并返回一个ModelAndView对象
				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
			}
			finally {
				if (asyncManager.isConcurrentHandlingStarted()) {
					return;
				}
			}
            
            // 设置视图名称，这里需要用到ViewNameTranslator接口
			applyDefaultViewName(request, mv);

            // 调用拦截器的后置处理方法
			mappedHandler.applyPostHandle(processedRequest, response, mv);
		}
		catch (Exception ex) {
			dispatchException = ex;
		}

        // 处理分发返回的结果，包括了异常的处理、ModelAndView的处理
        // 以及处理拦截器链最后的afterCompetion(request, response)方法。
		processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
	}
	catch (Exception ex) {
        // 如果有异常或错误，调用HandlerInterceptor#AfterCompletion()
		triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
	}
	catch (Error err) {
		triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);
	}
	finally {
		if (asyncManager.isConcurrentHandlingStarted()) {
			mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
			return;
		}
		if (multipartRequestParsed) {
			cleanupMultipart(processedRequest);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;2-获取handlerexecutorchain对象&#34;&gt;2. 获取HandlerExecutorChain对象&lt;/h5&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在DispatchServlet中，HandlerExecutorChain对象贯穿了整个doDispatch()方法，这是一个非常重要的对象，它包含了处理对象handler和拦截器集合interceptors。HandlerInterceptor拦截器的处理都是在HandlerExecutorChain中处理的。下面是HandlerExecutorChain的属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//处理器对象
private final Object handler;
//拦截器集合
private HandlerInterceptor[] interceptors;
private List&amp;lt;HandlerInterceptor&amp;gt; interceptorList;
//执行到拦截器的索引位置
private int interceptorIndex = -1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在DispatchServlet中，调用getHandler(HttpServletRequest request)方法返回HandlerExecutionChain对象，下面看看这个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
	// 遍历HandlerMapping对象
	// handlerMappings在DispatchedServlet启动时就初始化好了，可以参考上一篇中分析
	for (HandlerMapping hm : this.handlerMappings) {
		//找到一个符合的就返回
		HandlerExecutionChain handler = hm.getHandler(request);
		if (handler != null) {
			return handler;
		}
	}
	return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
从上面可以看出，HandlerExecutionChain的创建是由HandlerMapping接口来实现的。关于HandlerMapping接口是如何创建HandlerExecutionChain对象的具体细节，在下一篇中我们详细分析。&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&#34;3-获取handleradapter对象和调用&#34;&gt;3 获取HandlerAdapter对象和调用&lt;/h6&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
HandlerAdapter接口的主要功能是：使用被给的handler对象来处理请求，然后返回ModelAndView对象。这里的handler是创建HandlerExecutionChain时就应用创建好的。handler对象可以是Controller、HandlerMethod、Servlet等，也可以是其他自定义的对象类型。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
HandlerAdapter接口提供了两个方法，方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 返回该HandlerAdapter是否支持处理给定的handler对象
 */
boolean supports(Object handler);

/**
 * 使用handler对象处理请求，调用真实的请求方法并返回ModelAndView
 */
ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
关于HandlerAdapter#handle(&amp;hellip;)方法处理请求的详细内容，我们放在后续篇章中讲解。&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&#34;4-handlerinterceptor-拦截器&#34;&gt;4.HandlerInterceptor 拦截器&lt;/h6&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
HandlerInterceptor接口提供了3个方法，方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 该方法是拦截器的前置处理方法，是在真实请求处理之前被调用。
 * 如果方法返回true，则调用拦截器链中的下一个拦截器，知道所有拦截器调用完成。
 * 如果方法返回false，则表示该请求被拦截器，请求结束。
 */
boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
    throws Exception;

/**
 * 该方法是拦截器的后置处理方法，是在真实请求之后被调用，但在试图渲染之前。
 */
void postHandle(
		HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)
		throws Exception;

/**
 * 该方法在请求处理完成之后调用，也就是说此时视图渲染已经完成。
 * 该方法通常用在清除资源。
 * 该方法可以执行的前置条件是： 拦截器链中所有的preHandle都返回true。
 * 该方法在拦截器中是反序执行的，也就是说第一个拦截器最后执行这个方法。
 */
void afterCompletion(
		HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
		throws Exception;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
关于拦截器的具体分析和SpringMVC中提供有哪些功能的拦截器，我们在后续在分篇章讲解，这里先做一个初步的认识。&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&#34;5-返回异常处理-modelandview处理&#34;&gt;5.返回异常处理、ModelAndView处理&lt;/h6&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在上面分析doDispatch()方法时，可以发现方法中对异常进行了捕获，并将捕获的异常传参到processDispatchResult()方法中去。下面我们就针对processDispatchResult()方法分析。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
		HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception {

	boolean errorView = false;
    
    // 如果发生了异常，则处理异常情况
	if (exception != null) {
	    // 如果是视图异常，则返回该ModelAndView视图
		if (exception instanceof ModelAndViewDefiningException) {
			mv = ((ModelAndViewDefiningException) exception).getModelAndView();
		}
		else {
		    // 处理异常，并返回一个异常视图
			Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
			mv = processHandlerException(request, response, handler, exception);
			errorView = (mv != null);
		}
	}

	// 处理返回的视图
	if (mv != null &amp;amp;&amp;amp; !mv.wasCleared()) {
	    // 渲染视图
		render(mv, request, response);
		if (errorView) {
			WebUtils.clearErrorRequestAttributes(request);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
通过这篇文章的分析，我们了解了SpringMVC的请求分发过程。当然，由于篇幅过长，我们还有很多细节性的东西没有分析到。相关的细节我们在后续的篇章中分析。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>SpringMVC源码分析(1) DispatchServlet初始化</title>
            <link>http://www.xiaoqiyiye.com/2015/10/21/spring/</link>
            <pubDate>Wed, 21 Oct 2015 23:43:51 &#43;0800</pubDate>
            <author>CoderZh</author>
            <guid>http://www.xiaoqiyiye.com/2015/10/21/spring/</guid>
            <description>&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
这篇文章我们来分析一下SpringMVC中DispatchServlet的启动过程。我们还是先从配置文件来看，因为配置文件会最直观地告诉我们从哪里开始分析。在使用SpringMVC时，大家都知道需要在web.xml中如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;servlet&amp;gt;
 &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
 &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
 &amp;lt;init-param&amp;gt;
 	&amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
 	&amp;lt;param-value&amp;gt;
 		classpath:applicationContext-mvc.xml
 	&amp;lt;/param-value&amp;gt;
 &amp;lt;/init-param&amp;gt;
 &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
 &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
 &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
通过如上配置，将SpringMVC的配置文件applicationContext-mvc.xml设置到DispatcherServlet中去。DispatchServlet继承了HttpServlet，因此初始化工作在init()方法中实现。DispatchServlet的继承关系为:
DispatchServlet &amp;ndash;&amp;gt; FrameworkServlet &amp;ndash;&amp;gt; HttpServletBean &amp;ndash;&amp;gt; HttpServlet。下面我们进入到HttpServletBean#init()方法看看初始化的过程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final void init() throws ServletException {

	try {
        
        //获取Servlet参数，将信息都存放到BeanWrapper这个对象中去
		PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);
		BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);
		ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());
		bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));
		
		//这是一个钩子方法，子类可以去处理BeanWrapper对象
        initBeanWrapper(bw);
		bw.setPropertyValues(pvs, true);
	}
	catch (BeansException ex) {
		logger.error(&amp;quot;Failed to set bean properties on servlet &#39;&amp;quot; + getServletName() + &amp;quot;&#39;&amp;quot;, ex);
		throw ex;
	}

	// 真正的初始化让子类去完成，也就是FrameworkServlet类
	initServletBean();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
接下来，跟踪到FrameworkServlet#initServletBean()，这个方法没什么好说的，就一句重要的代码，initWebApplicationContext()这个方法。这个方法去初始化Spring容器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected final void initServletBean() throws ServletException {
	try {
        // 初始化Spring容器
		this.webApplicationContext = initWebApplicationContext();
		// 钩子方法，可以在容器加载完后，做一些初始化操作。
        initFrameworkServlet();
	}
	catch (ServletException ex) {
		throw ex;
	}
	catch (RuntimeException ex) {
		throw ex;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
那么，我们去看看容器是怎么初始化的？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected WebApplicationContext initWebApplicationContext() {

    // 还记得SpringWeb容器吗
    // 这里就是去获取SpringWeb容器当作根容器，把它作为SpringMVC的父容器
	WebApplicationContext rootContext =
			WebApplicationContextUtils.getWebApplicationContext(getServletContext());
			
	WebApplicationContext wac = null;

    // 如果使用了带webApplicationContext参数的构造方法，就调用这里，
    // 设置父类容器并刷新启动（以上XML配置情况不会执行这里）
	if (this.webApplicationContext != null) {
		wac = this.webApplicationContext;
		if (wac instanceof ConfigurableWebApplicationContext) {
			ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;
			if (!cwac.isActive()) {
				if (cwac.getParent() == null) {
					cwac.setParent(rootContext);
				}
				configureAndRefreshWebApplicationContext(cwac);
			}
		}
	}

    // 从ServletContext中找，看是否有容器存在
	if (wac == null) {
		wac = findWebApplicationContext();
	}
    
    // 如果没有找到，则去创建一个新的容器，并设置rootContext为父容器
	if (wac == null) {
	    // 这里会启动容器
		wac = createWebApplicationContext(rootContext);
	}

    // 判断是否已经触发过监听器，如果没有则会调用onRefresh(wac)
    // 否则，表示容器已经启动过，refreshEventReceived=true，不会再调用。         
    // 具体细节可查看FrameworkServlet内部类ContextRefreshListener。
    // onRefresh(wac)是一个钩子方法，具体实现是在DispatcherServlet中实现的
    // 这个方法主要初始化了一系列的SpringMVC相关对象（策略对象）
	if (!this.refreshEventReceived) {
		onRefresh(wac);
	}

    // 把新的容器作为属性设置到ServletContext中
    // attrName属性key为&amp;quot;FrameworkServlet.CONTEXT.&amp;quot; + servletName
	if (this.publishContext) {
		String attrName = getServletContextAttributeName();
		getServletContext().setAttribute(attrName, wac);
	}

	return wac;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
到目前为止，我们还没有看看容器真正启动，启动是在createWebApplicationContext(rootContext)中完成的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected WebApplicationContext createWebApplicationContext(ApplicationContext parent) {

    // 获取容器的类型，可以在web.xml中设置contextClass参数配置
	Class&amp;lt;?&amp;gt; contextClass = getContextClass();

    // 实例化容器对象
	ConfigurableWebApplicationContext wac =
			(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);

	wac.setEnvironment(getEnvironment());
	
    // 设置Spring Web容器作为父容器
	wac.setParent(parent);
    // 设置在web.xml中配置的applicationContext-mvc.xml配置文件
	wac.setConfigLocation(getContextConfigLocation());

    // 开始启动容器
	configureAndRefreshWebApplicationContext(wac);

	return wac;
}

protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) {
    
    // 设置Servlet相关信息
	wac.setServletContext(getServletContext());
	wac.setServletConfig(getServletConfig());
	wac.setNamespace(getNamespace());

    // 添加容器监听器
	wac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener()));

	// 这是一个钩子方法，负责context的后置处理，其实和下面的applyInitializers(wac)一样
	postProcessWebApplicationContext(wac);

    // 在容器启动前，可以自定义容器初始化，配置参数contextInitializerClasses可以实现，只能配置ApplicationContextInitializer实现类，这个和Spring Web启动时一样，参见ContextLoaderListener。
	applyInitializers(wac);

    // 启动容器
	wac.refresh();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
到目前为止，Dispatcher的初始化已经分析的差不多了，和前面分析的SpringMVC容器启动基本上相似。上面提到了onRefresh(wac)方法，这个方法是初始化的尾声了，看看onRefresh(wac)方法做了什么事情，怎么把我们带进SpringMVC的世界呢？&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在onRefresh(wac)中就调用了initStrategies(context)，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void initStrategies(ApplicationContext context) {
	initMultipartResolver(context);
	initLocaleResolver(context);
	initThemeResolver(context);
	initHandlerMappings(context);
	initHandlerAdapters(context);
	initHandlerExceptionResolvers(context);
	initRequestToViewNameTranslator(context);
	initViewResolvers(context);
	initFlashMapManager(context);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
看到上面的代码，似乎让我们熟悉起来，这些都是SpringMVC中关键的接口。上面的初始化方法处理的方式都很相似，这里就不一一分析了，分析下initHanderMappings(context)就可以了，只需明白在DispatcherServlet开始处理请求分发时，这些对象都已经初始化好了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void initHandlerMappings(ApplicationContext context) {
	this.handlerMappings = null;

    // 是否检测所有的HandlerMapping（也会去父容器检测）
    // 也就是说检测我们是否在配置文件中配置了HandlerMapping接口的Bean
	if (this.detectAllHandlerMappings) {
		Map&amp;lt;String, HandlerMapping&amp;gt; matchingBeans =
				BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);
		if (!matchingBeans.isEmpty()) {
			this.handlerMappings = new ArrayList&amp;lt;HandlerMapping&amp;gt;(matchingBeans.values());
			// 排序
			OrderComparator.sort(this.handlerMappings);
		}
	}
	else {
		try {
            // 只检测一个HandlerMapping，根据默认handlerMapping的Bean名称去查找。
			HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);
			this.handlerMappings = Collections.singletonList(hm);
		}
		catch (NoSuchBeanDefinitionException ex) {
		}
	}

    // 如果还是没有检测到，则确保有一个默认的HandlerMapping存在，
    // 这个默认的HandlerMapping是BeanNameUrlHandlerMapping，
    // SpringMVC的默认策略是配置在DispatcherServlet.properties属性文件中。
	if (this.handlerMappings == null) {
		this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
这样SpringMVC中的HandlerMapping接口实现类就已经初始化好了，其他接口的初始化处理过程也是类似的，就不一一分析了。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
关于默认的配置文件DispatcherServlet.properties，提供了8个接口的默认类型。DispatcherServlet.properties文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver

org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver

org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\
	org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping

org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\
	org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\
	org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter

org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\
	org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\
	org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver

org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator

org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver

org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
关于DispatchServlet启动过程就分析到这里，总结一下DispatchServlet的流程：
1. 创建容器对象
2. 启动容器对象(前两步流程和SpringWEB的启动一样的)
3. 初始化SpringMVC相关联的一些策略接口&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
通过对这篇文章的了解，只是可以启动SpringMVC了，为接下来的SpringMVC使用做准备。但是SpringMVC到底是如何处理请求的呢？这个问题我们在后面的篇章中会分析到。DispatchServlet的核心部分，处理请求分发过程。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>

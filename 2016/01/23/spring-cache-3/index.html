<!DOCTYPE html>

<meta charset="utf-8">


<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

<meta property="og:url" content="http://www.xiaoqiyiye.com/">


<meta property="og:type" content="article">
<meta property="og:title" content="SpringCache源码分析(3) @CachePut、@Cacheable、@CacheEvict注解解析 &middot; Xiaoqiyiye">

<meta property="og:site_name" content="Xiaoqiyiye">

<title>
    
    SpringCache源码分析(3) @CachePut、@Cacheable、@CacheEvict注解解析
    
</title>


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap-theme.min.css">
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
<link rel="stylesheet" href="//yandex.st/highlightjs/8.0/styles/solarized_dark.min.css">
<link rel="stylesheet" href="http://www.xiaoqiyiye.com//css/styles.css">
<link rel="stylesheet" href="http://www.xiaoqiyiye.com//css/custom.css">


<link rel="shortcut icon" href="http://www.xiaoqiyiye.com//assets/favicon.ico">


<link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.xiaoqiyiye.com//index.xml">


<div class="container">
    <header class="nav">
        <nav class="navbar navbar-default">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="http://www.xiaoqiyiye.com/">Xiaoqiyiye</a>
                </div>

                <div class="collapse navbar-collapse" id="navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="http://www.xiaoqiyiye.com//post">博客</a></li>
                        <li><a href="http://www.xiaoqiyiye.com//tags">分类</a></li>
                        
                        <li><a href="http://www.xiaoqiyiye.com/about/">关于我</a></li>
                        
                    </ul>

                    <ul class="nav navbar-nav navbar-right">
                        
                        
                        
                        <li>
                            <a href="https://github.com/xiaoqiyiye" target="_blank">
                                <i class="fa fa-github-square"></i>
                                GitHub
                            </a>
                        </li>
                        
                        
                    </ul>
                </div>
            </div>
        </nav>
    </header>


<div class="row">
    <div class="col-md-8">
        <article class="post">

            <header>
                <div class="post-date">
                    <span class="glyphicon glyphicon-calendar"></span>
                    <time datetime="2016年1月23日">
                        2016年1月23日
                    </time>
                </div>
                <h1 class="post-title">
                    <a href="http://www.xiaoqiyiye.com/2016/01/23/spring-cache-3/">SpringCache源码分析(3) @CachePut、@Cacheable、@CacheEvict注解解析</a>
                </h1>
            </header>

            <div class="post-content">
                

<hr />

<p>&#160;&#160;&#160;&#160;
从上一篇中我们提及到，既然方法使用了@CachePut、@Cacheable、@CacheEvict这些注解，那么，执行方法是怎么知道设置了哪些注解信息的呢？ 下面我们分析一下注解的解析。但，在分析之前我们需要知道缓存操作封装类CacheOperation。</p>

<hr />

<h3 id="cacheoperation缓存操作封装类">CacheOperation缓存操作封装类</h3>

<p>&#160;&#160;&#160;&#160;
CacheOperation抽象类表示缓存的基本操作，封装了缓存基本操作的一些属性信息，也就是在@CachePut、@Cacheable、@CacheEvict中配置的属性信息。CacheOperation有三个实现类，分别是CachePutOperation、CacheableOperation、CacheEvictOperation，不用说也知道这是对注解信息的封装类。下面简单的看一下CacheOperation封装了哪些信息。</p>

<pre><code>public abstract class CacheOperation implements BasicOperation {

	private String name = &quot;&quot;;

	private Set&lt;String&gt; cacheNames = Collections.emptySet();

	private String key = &quot;&quot;;

	private String keyGenerator = &quot;&quot;;

	private String cacheManager = &quot;&quot;;

	private String cacheResolver = &quot;&quot;;

	private String condition = &quot;&quot;;

	/* 省略了一些setter、getter方法 */

}
</code></pre>

<p>&#160;&#160;&#160;&#160;
这些属性是不是很熟悉，就是在配置@CachePut、@Cacheable、@CacheEvict使用的一些公共属性。CacheOperation没什么好分析的，我们只要知道最终注解信息都被转换成CacheOperation对象就可以了。至于是哪个具体的实现，我们现在还不用关心，后面会知道。</p>

<hr />

<h3 id="cacheannotationparser缓存注解解析器">CacheAnnotationParser缓存注解解析器</h3>

<p>&#160;&#160;&#160;&#160;
CacheAnnotationParser接口提供了2个方法，分别对类和方法上的注解进行解析。因为我们知道@CachePut可以在类或方法上进行注解。</p>

<p>&#160;&#160;&#160;&#160;
CacheAnnotationParser这是一个策略接口，它是委派给AnnotationCacheOperationSource来执行的，AnnotationCacheOperationSource内部持有一个CacheAnnotationParser集合，可以执行一系列的CacheAnnotationParser实现。也就是说我们可以自定义像@CachePut一样的注解，然后提供对应的CacheAnnotationParser解析器，达到我们自定义缓存功能的效果。下面是CacheAnnotationParser接口的源码。</p>

<pre><code>/**
 * CacheAnnotationParser是为解析注解提供的一个策略接口，AnnotationCacheOperationSource 会委派一些解析器来解析特定的注解类型，像Spring Cache的@Cacheable、@CachePut、@CacheEvict
 */
public interface CacheAnnotationParser {

	/**
     * 对给定类型上的缓存注解进行解析，如果没有则返回null
	 * @see AnnotationCacheOperationSource#findCacheOperations(Class)
	 */
	Collection&lt;CacheOperation&gt; parseCacheAnnotations(Class&lt;?&gt; type);

	/**
     * 对给定方法上的缓存注解进行解析，如果没有则返回null
	 * @see AnnotationCacheOperationSource#findCacheOperations(Method)
	 */
	Collection&lt;CacheOperation&gt; parseCacheAnnotations(Method method);

}
</code></pre>

<p>&#160;&#160;&#160;&#160;
那么@CachePut、@Cacheable、@CacheEvict到底是哪个类来解析的呢？ 就是，SpringCacheAnnotationParser。下面我们看看SpringCacheAnnotationParser是如何解析注解的，我们还是看看CacheAnnotationParser提供的接口方法，代码如下：</p>

<pre><code>@Override
public Collection&lt;CacheOperation&gt; parseCacheAnnotations(Class&lt;?&gt; type) {
	//获取@CacheConfig注解信息
	DefaultCacheConfig defaultConfig = getDefaultCacheConfig(type);
	//解析其他的缓存注解@Caching、@CachePut、@Cacheable、@CacheEvict
	return parseCacheAnnotations(defaultConfig, type);
}

@Override

public Collection&lt;CacheOperation&gt; parseCacheAnnotations(Method method) {
	DefaultCacheConfig defaultConfig = getDefaultCacheConfig(method.getDeclaringClass());
	return parseCacheAnnotations(defaultConfig, method);
}
</code></pre>

<p>&#160;&#160;&#160;&#160;
从上面的代码可以看出，这2个方法解析方式一样，都调用了相同的方法。第一，解析@CacheConfig注解，调用了getDefaultCacheConfig(Class&lt;?&gt; target)方法；第二，解析其他缓存注解，都调用了parseCacheAnnotations(DefaultCacheConfig cachingConfig, AnnotatedElement ae)这个方法。</p>

<ol>
<li><p>DefaultCacheConfig获取@CacheConfig注解信息</p>

<pre><code> DefaultCacheConfig getDefaultCacheConfig(Class&lt;?&gt; target) {
    
    //直接获取目标类型上的@CacheConfig注解，如果有则将属性信息设置好，如果没有则给定一个默认的DefaultCacheConfig对象。
    CacheConfig annotation = AnnotationUtils.getAnnotation(target, CacheConfig.class);
    
    if (annotation != null) {
        return new DefaultCacheConfig(annotation.cacheNames(), annotation.keyGenerator(),
                annotation.cacheManager(), annotation.cacheResolver());
    }
    
    return new DefaultCacheConfig();
}
</code></pre></li>

<li><p>获取CacheOperation集合信息</p>

<pre><code>protected Collection&lt;CacheOperation&gt; parseCacheAnnotations(DefaultCacheConfig cachingConfig, AnnotatedElement ae) {
    
    Collection&lt;CacheOperation&gt; ops = null;
    
    //解析@Cacheable
    Collection&lt;Cacheable&gt; cacheables = getAnnotations(ae, Cacheable.class);
    if (cacheables != null) {
        ops = lazyInit(ops);
        for (Cacheable cacheable : cacheables) {
            ops.add(parseCacheableAnnotation(ae, cachingConfig, cacheable));
        }
    }
    
    //解析@CacheEvict
    Collection&lt;CacheEvict&gt; evicts = getAnnotations(ae, CacheEvict.class);
    if (evicts != null) {
        ops = lazyInit(ops);
        for (CacheEvict evict : evicts) {
            ops.add(parseEvictAnnotation(ae, cachingConfig, evict));
        }
    }
    
    //解析@CachePut
    Collection&lt;CachePut&gt; puts = getAnnotations(ae, CachePut.class);
    if (puts != null) {
        ops = lazyInit(ops);
        for (CachePut put : puts) {
            ops.add(parsePutAnnotation(ae, cachingConfig, put));
        }
    }
    
    //解析@Caching
    Collection&lt;Caching&gt; cachings = getAnnotations(ae, Caching.class);
    if (cachings != null) {
        ops = lazyInit(ops);
        for (Caching caching : cachings) {
            ops.addAll(parseCachingAnnotation(ae, cachingConfig, caching));
        }
    }
        
    //最后，返回解析出来的所有缓存操作对象CacheOperation集合
    return ops;
}
</code></pre></li>
</ol>

<p>&#160;&#160;&#160;&#160;
这些代码虽然很简单，但是有些细节还是需要说明：
1. 如果存在自定义注解使用了@CachePut等这些缓存注解，该怎么解析呢？ 到底需不需解析到？
2. 前面说过@CachConfig是一个总注解配置，那么，@CacheConfig的注解信息如何优先于其他注解信息呢？
3. 在@CachePut、@Cacheable、@CacheEvict注解信息中，key和keyGenerator是排它性的，cacheManager和cacheResolve也是排它性的，为什么呢？</p>

<p>&#160;&#160;&#160;&#160;
答案就在我们的眼前，下面我们看看 getAnnotations(AnnotatedElement ae, Class<T> annotationType) 和 parsePutAnnotation(AnnotatedElement ae, DefaultCacheConfig defaultConfig, CachePut cachePut) （三个方法之选一个说明，其他两个都一样）</p>

<hr />

<h4 id="自定义注解中存在-cacheput等缓存注解">自定义注解中存在@CachePut等缓存注解</h4>

<p>&#160;&#160;&#160;&#160;
假设我们自定以了一个注解类型@UserCache，如下：</p>

<pre><code>@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Cacheable(value=&quot;user&quot;)
public @interface UserCache{

}
</code></pre>

<p>&#160;&#160;&#160;&#160;
如果一个方法使用了@UserCache，那么，@UserCache中使用的@Cacheable是否也应该包含该方法的缓存注解解析中去呢？ 答案是肯定的，需要包含。但是如果注解层级关系不止一层，如果是二层注解关系，又会是怎样的呢？多层次的注解关系是不会被解析到的。下面看看getAnnotations()这个方法，分析如下：</p>

<pre><code>private &lt;T extends Annotation&gt; Collection&lt;T&gt; getAnnotations(AnnotatedElement ae, Class&lt;T&gt; annotationType) {

	Collection&lt;T&gt; anns = new ArrayList&lt;T&gt;(2);

	//查找原生的注解
	T ann = ae.getAnnotation(annotationType);
	if (ann != null) {
		anns.add(AnnotationUtils.synthesizeAnnotation(ann, ae));
	}

	//扫描注解中的注解，注意：这里只包含了一层注解关系，如果出现多层次的注解关系是扫描不到的！
	for (Annotation metaAnn : ae.getAnnotations()) {
		ann = metaAnn.annotationType().getAnnotation(annotationType);
		if (ann != null) {
			anns.add(AnnotationUtils.synthesizeAnnotation(ann, ae));
		}
	}

	return (anns.isEmpty() ? null : anns);
}
</code></pre>

<hr />

<h4 id="cacheconfig的高优先级别">@CacheConfig的高优先级别</h4>

<p>&#160;&#160;&#160;&#160;
前面早已说明过@CacheConfig的作用要高于@CachePut、@Cacheable、@CacheEvict，但是，为什么呢？这些也只能算是我们的道听途说。作为一个Coding，我们不要那些道听途说，别人说的不一定是对的。下面的代码会给你一个真理，让你也知道：哦，原来就是这么简单！ 我们就拿@CachePut的解析来说，下面是解析的方法。（@Cacheable、@CacheEvict一样就不赘述啦）</p>

<pre><code>CacheOperation parsePutAnnotation(AnnotatedElement ae, DefaultCacheConfig defaultConfig, CachePut cachePut) {

	CachePutOperation op = new CachePutOperation();
	op.setCacheNames(cachePut.cacheNames());
	op.setCondition(cachePut.condition());
	op.setUnless(cachePut.unless());
	op.setKey(cachePut.key());
	op.setKeyGenerator(cachePut.keyGenerator());
	op.setCacheManager(cachePut.cacheManager());
	op.setCacheResolver(cachePut.cacheResolver());
	op.setName(ae.toString());

	//这里会去对op对象做一次重新的设定，到底做了什么，我想你会懂的！
	//这里会把@CacheConfig中配置的注解信息重新设置一边，也就是覆盖前面设置过的值。
	defaultConfig.applyDefault(op);
	validateCacheOperation(ae, op);

	return op;
}
</code></pre>

<hr />

<h4 id="key和keygenerator-cachemanager和cacheresolve排它性">key和keyGenerator、cacheManager和cacheResolve排它性</h4>

<p>&#160;&#160;&#160;&#160;
从下面的代码中，很容易知道，如果key和keyGenerator、cacheManager和cacheResolve同时存在就会抛出异常了。</p>

<pre><code>private void validateCacheOperation(AnnotatedElement ae, CacheOperation operation) {

	if (StringUtils.hasText(operation.getKey()) &amp;&amp; StringUtils.hasText(operation.getKeyGenerator())) {
		throw new IllegalStateException(&quot;Invalid cache annotation configuration on '&quot; +
				ae.toString() + &quot;'. Both 'key' and 'keyGenerator' attributes have been set. &quot; +
				&quot;These attributes are mutually exclusive: either set the SpEL expression used to&quot; +
				&quot;compute the key at runtime or set the name of the KeyGenerator bean to use.&quot;);
	}

	if (StringUtils.hasText(operation.getCacheManager()) &amp;&amp; StringUtils.hasText(operation.getCacheResolver())) {
		throw new IllegalStateException(&quot;Invalid cache annotation configuration on '&quot; +
				ae.toString() + &quot;'. Both 'cacheManager' and 'cacheResolver' attributes have been set. &quot; +
				&quot;These attributes are mutually exclusive: the cache manager is used to configure a&quot; +
				&quot;default cache resolver if none is set. If a cache resolver is set, the cache manager&quot; +
				&quot;won't be used.&quot;);
	}

}
</code></pre>

<hr />

<p>&#160;&#160;&#160;&#160;
@CacheConfig、@Caching、@CachePut、@Cacheable、@CacheEvict这些缓存注解的解析分析完了，总结一句话，就是将缓存注解都解析成了Collection&lt;CacheOperation&gt;对象。</p>

<p>&#160;&#160;&#160;&#160;
解析成Collection&lt;CacheOperation&gt;对象，什么时候调用呢？ 前面提及过CacheAnnotationParser提供了对缓存注解的解析策略。具体的调用并不是由CacheAnnotationParser直接处理的，而是由AnnotationCacheOperationSource委派给CacheAnnotationParser来处理。AnnotationCacheOperationSource是CacheOperationSource接口的实现类，也就是说调用工作是由CacheOperationSource来负责的。</p>

<hr />

<h3 id="cacheoperationsource-缓存操作调用">CacheOperationSource 缓存操作调用</h3>

<p>&#160;&#160;&#160;&#160;
下面，我们直接了当地看CacheOperationSource接口的定义：</p>

<pre><code>/**

 * 这个接口是由CacheInterceptor使用
 * Interface used by {@link CacheInterceptor}. Implementations know how to source
 */
public interface CacheOperationSource {

	/**
     * 方法功能很明确：为一个执行方法返回所有缓存注解的缓存操作集合
	 */
	Collection&lt;CacheOperation&gt; getCacheOperations(Method method, Class&lt;?&gt; targetClass);

}
</code></pre>

<p>&#160;&#160;&#160;&#160;
现在，我们的思路应该很清楚了。那就是，CacheInterceptor调用了CacheOperationSource，CacheOperationSource委派给CacheAnnotationParser去解析执行方法上的注解，然后返回一个Collection<CacheOperation>给CacheInterceptor。就是这样！</p>

<p>&#160;&#160;&#160;&#160;
CacheInterceptor怎么调用了CacheOperationSource我们现在暂且不管，下一篇中分析。 下面，我们看看，CacheOperationSource如何委派CacheAnnotationParser解析注解。</p>

<hr />

<h5 id="annotationcacheoperationsource-委派给注解解析器">AnnotationCacheOperationSource 委派给注解解析器</h5>

<p>&#160;&#160;&#160;&#160;
AnnotationCacheOperationSource的继承关系是： AnnotationCacheOperationSource &ndash;&gt; AbstractFallbackCacheOperationSource &ndash;&gt; CacheOperationSource。所以我们还是先从AbstractFallbackCacheOperationSource开始分析，然后分析AnnotationCacheOperationSource。</p>

<p>&#160;&#160;&#160;&#160;
首先，看看AbstractFallbackCacheOperationSource提供的属性和实现CacheOperationSource的接口方法：</p>

<pre><code>public abstract class AbstractFallbackCacheOperationSource implements CacheOperationSource {

	/**
	 * 这里的key是AnnotatedElementKey对象，这个对象只是对执行方法method和目标类型targetClass的包装。
	 * 也就是说，保证了method+targetClass产生key的唯一性。
	 */
	private final Map&lt;Object, Collection&lt;CacheOperation&gt;&gt; attributeCache =
			new ConcurrentHashMap&lt;Object, Collection&lt;CacheOperation&gt;&gt;(1024);

	/**
	 * 为调用的方法获取缓存属性，如果方法中找不到，则从类型中找。
	 */
	@Override
	public Collection&lt;CacheOperation&gt; getCacheOperations(Method method, Class&lt;?&gt; targetClass) {

		//获取key，也就是AnnotatedElementKey对象(当作一般的保证key唯一性标志就好了)
		Object cacheKey = getCacheKey(method, targetClass);

		//从Map中获取，如果获取不到，则进行解析
		Collection&lt;CacheOperation&gt; cached = this.attributeCache.get(cacheKey);

		if (cached != null) {
			return (cached != NULL_CACHING_ATTRIBUTE ? cached : null);
		}
		else {
			//解析执行方法的缓存操作集合
			Collection&lt;CacheOperation&gt; cacheOps = computeCacheOperations(method, targetClass);
			if (cacheOps != null) {
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Adding cacheable method '&quot; + method.getName() + &quot;' with attribute: &quot; + cacheOps);
				}
				this.attributeCache.put(cacheKey, cacheOps);
			}
			else {
				this.attributeCache.put(cacheKey, NULL_CACHING_ATTRIBUTE);
			}
			return cacheOps;
		}
	}

}
</code></pre>

<p>&#160;&#160;&#160;&#160;
上面的代码很容易明白：当一个方法执行时，会去解析该方法的缓存操作集合，解析后放入到attributeCache这个Map中去，以便下次直接获取。</p>

<p>&#160;&#160;&#160;&#160;
但是，是怎么计算一个执行方法的缓存操作集合呢？ 在computeCacheOperations(method, targetClass)这个类中，下面跟进去瞧瞧。</p>

<pre><code>private Collection&lt;CacheOperation&gt; computeCacheOperations(Method method, Class&lt;?&gt; targetClass) {

	// 判断no-public方法是否可以获取缓存操作集合，子类可以重写allowPublicMethodsOnly()方法，默认返回的是false。
	if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {
		return null;
	}

	//方法可能是接口上的，所以需要去找到一个特定的方法。
	Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);
	specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);

	//首先，试着从方法上找缓存操作集合（这是一个抽象方法）
	Collection&lt;CacheOperation&gt; opDef = findCacheOperations(specificMethod);
	if (opDef != null) {
		return opDef;
	}

	//其次，再试着从类型上找缓存操作集合（这也是一个抽象方法）
	opDef = findCacheOperations(specificMethod.getDeclaringClass());
	if (opDef != null) {
		return opDef;
	}

	//如果前面都没有找到，并且specificMethod != method，则从原始执行方法method上去找
	if (specificMethod != method) {
		//先从方法上找
		opDef = findCacheOperations(method);
		if (opDef != null) {
			return opDef;
		}

		//最后，再从类型上找
		return findCacheOperations(method.getDeclaringClass());
	}
	
	return null;
}
</code></pre>

<p>&#160;&#160;&#160;&#160;
从上面的分析可以知道，AbstractFallbackCacheOperationSource做了2件事情：第一，增加了Map作为缓存，以便后续可以直接获取。第二，处理了方法fallback（备援）的情况。</p>

<p>&#160;&#160;&#160;&#160;
接下来，我们需要看看findCacheOperations(specificMethod)和findCacheOperations(specificMethod.getDeclaringClass())这两个抽象方法是怎么实现的了，不用到说，实现类就是AnnotationCacheOperationSource了。我们再想想，有一个接口提供了和这两个类似的方法，那就是CacheAnnotationParser接口。到这里，我们终于把CacheOperationSource和CacheAnnotationParser联系起来了。下面再看看代码是如何实现的：</p>

<pre><code>public class AnnotationCacheOperationSource extends AbstractFallbackCacheOperationSource implements Serializable {

	//定义是否只用public方法可以被缓存操作
	private final boolean publicMethodsOnly;

	//缓存注解解析器集合
	private final Set&lt;CacheAnnotationParser&gt; annotationParsers;

	@Override
	protected Collection&lt;CacheOperation&gt; findCacheOperations(final Class&lt;?&gt; clazz) {
	
		//实际上就是遍历annotationParsers
		return determineCacheOperations(new CacheOperationProvider() {
			@Override
			public Collection&lt;CacheOperation&gt; getCacheOperations(CacheAnnotationParser parser) {
				return parser.parseCacheAnnotations(clazz);
			}
		});

	}

	@Override
	protected Collection&lt;CacheOperation&gt; findCacheOperations(final Method method) {

		return determineCacheOperations(new CacheOperationProvider() {
			@Override
			public Collection&lt;CacheOperation&gt; getCacheOperations(CacheAnnotationParser parser) {
				return parser.parseCacheAnnotations(method);
			}
		});

	}

	/**
	 * 这里就是在遍历CacheAnnotationParser集合了，最后把所有的Collection&lt;CacheOperation&gt;返回
	 */
	protected Collection&lt;CacheOperation&gt; determineCacheOperations(CacheOperationProvider provider) {

		Collection&lt;CacheOperation&gt; ops = null;
		for (CacheAnnotationParser annotationParser : this.annotationParsers) {
			Collection&lt;CacheOperation&gt; annOps = provider.getCacheOperations(annotationParser);
			if (annOps != null) {
				if (ops == null) {
					ops = new ArrayList&lt;CacheOperation&gt;();
				}
				ops.addAll(annOps);
			}
		}

		return ops;
	}

	/**
	 * 重写了父类的方法，可以配置no-public缓存操作
	 */
	@Override
	protected boolean allowPublicMethodsOnly() {
		return this.publicMethodsOnly;
	}

	/**
	 * 只是为了便于遍历调用CacheAnnotationParser
	 */
	protected interface CacheOperationProvider {
		Collection&lt;CacheOperation&gt; getCacheOperations(CacheAnnotationParser parser);
	}

}
</code></pre>

<h3 id="总结">总结</h3>

<ol>
<li>CacheAnnotationParser将@CachePut等注解解析成CacheOperation集合对象</li>
<li>CacheOperationSource委派CacheAnnotationParser来获取解析到的CacheOperation集合</li>
<li>CacheInterceptor调用CacheOperationSource</li>
</ol>

<p>&#160;&#160;&#160;&#160;
在下一篇中我们继续分析CacheInterceptor的调用。</p>

            </div>

            <aside>
                
                <ul class="list-inline post-tags">
                    
                    <li>
                        <a href="http://www.xiaoqiyiye.com//tags/spring-cache">
                            <i class="fa fa-tags"></i>
                            spring cache
                        </a>
                    </li>
                    
                </ul>

                
                
                <h3>相关博客</h3>
                <ul class="post-rels">
                    
                    
                    
                    
                    
                    
                    <li><a href="http://www.xiaoqiyiye.com/2016/01/24/spring-cache-4/">SpringCache (4) CacheInterceptor、</a></li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li><a href="http://www.xiaoqiyiye.com/2016/01/23/spring-cache-2/">SpringCache源码分析(2) @CachePut、@Cacheable、@CacheEvict、@Caching注解</a></li>
                    
                    
                    
                    
                    
                    <li><a href="http://www.xiaoqiyiye.com/2016/01/23/spring-cache-1/">SpringCache源码分析(1)  CacheManager和Cache</a></li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                </ul>
            </aside>
            
            
            <footer>

                <nav>
                    <ul class="pager">

                        
                        <li class="previous"><a href="http://www.xiaoqiyiye.com/2016/01/24/spring-cache-4/"><span aria-hidden="true">&larr;</span> Older</a></li>
                        

                        <li><a href="http://www.xiaoqiyiye.com//post">All Posts</a></li>

                        
                        <li class="next"><a href="http://www.xiaoqiyiye.com/2016/01/23/spring-cache-2/">Newer <span aria-hidden="true">&rarr;</span></a></li>
                        

                    </ul>
                </nav>

                
                
                
            </footer>

        </article>
    </div>
    <div class="col-md-4">
        
<aside>
    <div class="row">

        <div class="col-xs-12 col-sm-4 col-md-12">
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h2 class="panel-title">最近博客</h2>
                </div>
                <div class="list-group">
                    
                    <a href="http://www.xiaoqiyiye.com/2016/01/24/spring-cache-4/" class="list-group-item">SpringCache (4) CacheInterceptor、</a>
                    
                    <a href="http://www.xiaoqiyiye.com/2016/01/23/spring-cache-3/" class="list-group-item">SpringCache源码分析(3) @CachePut、@Cacheable、@CacheEvict注解解析</a>
                    
                    <a href="http://www.xiaoqiyiye.com/2016/01/23/spring-cache-2/" class="list-group-item">SpringCache源码分析(2) @CachePut、@Cacheable、@CacheEvict、@Caching注解</a>
                    
                    <a href="http://www.xiaoqiyiye.com/2016/01/23/spring-cache-1/" class="list-group-item">SpringCache源码分析(1)  CacheManager和Cache</a>
                    
                    <a href="http://www.xiaoqiyiye.com/2015/10/22/spring/handlermapping" class="list-group-item">SpringMVC源码分析(3) HandlerMapping分析</a>
                    
                    <a href="http://www.xiaoqiyiye.com/2015/10/22/spring/" class="list-group-item">SpringMVC源码分析(2) DispatchServlet请求分发</a>
                    
                    <a href="http://www.xiaoqiyiye.com/2015/10/21/spring/" class="list-group-item">SpringMVC源码分析(1) DispatchServlet初始化</a>
                    
                    <a href="http://www.xiaoqiyiye.com/2015/10/18/spring/" class="list-group-item">SpringWeb源码分析(1) Web容器启动</a>
                    
                    <a href="http://www.xiaoqiyiye.com/about/" class="list-group-item">关于我</a>
                    
                </div>
            </div>
        </div>

        <div class="col-xs-12 col-sm-4 col-md-12">
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h2 class="panel-title">分类</h2>
                </div>
                <div class="list-group">
                    
                    
                    
                    <a href="http://www.xiaoqiyiye.com//tags/spring" class="list-group-item">
                        <span class="badge">1</span>
                        spring
                    </a>
                    
                    
                    <a href="http://www.xiaoqiyiye.com//tags/spring-cache" class="list-group-item">
                        <span class="badge">4</span>
                        spring-cache
                    </a>
                    
                    
                    <a href="http://www.xiaoqiyiye.com//tags/spring-mvc" class="list-group-item">
                        <span class="badge">3</span>
                        spring-mvc
                    </a>
                    
                </div>
            </div>
        </div>

    </div>
</aside>

    </div>
</div>

</div>
<hr>

<footer class="container copy">
    <p>&copy; 2016  linya </p>
	<p>Powered by <a href="http://github.com/xiaoqiyiye" target="_blank">Xiaoqiyiye</a></p>
	<p>Email: linya_xiaoqiyiye@126.com</p>
</footer>

<script src="//code.jquery.com/jquery-2.1.3.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
<script src="//yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>

<script>
document.write('<script src="//sharebutton.net/plugin/sharebutton.php?type=horizontal&u=' + encodeURIComponent(document.location.href) + '"></scr' + 'ipt>');
</script>


<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Xiaoqiyiye</title>
        <link>http://www.xiaoqiyiye.com/post/</link>
        <language>zh-CN</language>
        <author>xiaoqiyiye</author>
        <rights>Copyright (c) 2015-2016, xiaoqiyiye all rights reserved.</rights>
        <updated>Sun, 24 Jan 2016 13:00:00 &#43;0800</updated>
        
        <item>
            <title>SpringCache (4) CacheInterceptor、</title>
            <link>http://www.xiaoqiyiye.com/2016/01/24/spring-cache-4/</link>
            <pubDate>Sun, 24 Jan 2016 13:00:00 &#43;0800</pubDate>
            <author>CoderZh</author>
            <guid>http://www.xiaoqiyiye.com/2016/01/24/spring-cache-4/</guid>
            <description>

&lt;hr /&gt;

&lt;h3 id=&#34;缓存拦截器的实现&#34;&gt;缓存拦截器的实现&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
这一篇我们讲讲SpringCache对方法的拦截器实现，也就是CacheInterceptor。在使用SpringCache我们会比较关注的问题，为什么对一个方法使用@CachePut注解后，就可以达到缓存的效果呢？下面我们将揭开这层面纱。Spring Cache实现对方法的拦截功能，是由CacheInterceptor提供的。下面直接看看CacheInterceptor是怎么做的呢？&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
CacheInterceptor实现了MethodInterceptor接口，在Spring AOP中，MethodInterceptor的功能是做方法拦截。现在应该明白，为什么使用@CachePut等注解后可以实现缓存操作，因为方法被拦截处理了。CacheInterceptor的实现很简单，啥都不用啰说了，先看看代码实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class CacheInterceptor extends CacheAspectSupport implements MethodInterceptor, Serializable {

	/*
	 *被拦截的方法都会调用invoke方法，不懂的可以先看看Spring AOP。
	 */
	@Override
	public Object invoke(final MethodInvocation invocation) throws Throwable {
		Method method = invocation.getMethod();
		
		//这里就是对执行方法调用的一次封装，主要是为了处理对异常的包装。
		CacheOperationInvoker aopAllianceInvoker = new CacheOperationInvoker() {
			@Override
			public Object invoke() {
				try {
					return invocation.proceed();
				}
				catch (Throwable ex) {
					throw new ThrowableWrapper(ex);
				}
			}
		};

		try {
			//真正地去处理缓存操作的执行，很显然这是父类的方法，所以我们要到父类CacheAspectSupport中去看看。
			return execute(aopAllianceInvoker, invocation.getThis(), method, invocation.getArguments());
		}
		catch (CacheOperationInvoker.ThrowableWrapper th) {
			throw th.getOriginal();
		}
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
下面，我们再看看CacheAspectSupport#execute(&amp;hellip;)这个方法中具体怎么进行缓存操作的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected Object execute(CacheOperationInvoker invoker, Object target, Method method, Object[] args) {

	//标志Spring加载元素是否都准备好了，是否可以执行了
	if (this.initialized) {
		Class&amp;lt;?&amp;gt; targetClass = getTargetClass(target);
		//这里使用的就是CacheOperationSource，来获取执行方法上所有的缓存操作集合。如果有缓存操作则执行到execute(...)，如果没有就执行invoker.invoke()直接调用执行方法了。
		Collection&amp;lt;CacheOperation&amp;gt; operations = getCacheOperationSource().getCacheOperations(method, targetClass);
		if (!CollectionUtils.isEmpty(operations)) {
			return execute(invoker, new CacheOperationContexts(operations, method, args, target, targetClass));
		}
	}

	return invoker.invoke();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在上面的代码中出现了CacheOperationContexts对象，这个对象只是为了便于获取每种具体缓存操作集合。我们知道所有的缓存操作CachePutOperation、CacheableOperation、CacheEvictOperation都存放在operations这个集合中，不便于获取具体的缓存操作，所以封装成了缓存操作上下文CacheOperationContexts这个类。接下来，我们继续看看核心代码，庐山真面目即将揭晓。先罗列一下@CachePut、@Cacheable、@CacheEvict的功能，再来看看代码是怎么实现的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;@CachePut  &amp;ndash; 执行方法后，将方法返回结果存放到缓存中。不管有没有缓存过，执行方法都会执行，并缓存返回结果（unless可以否决进行缓存）。（当然，这里说的缓存都要满足condition条件）&lt;/li&gt;
&lt;li&gt;@Cacheable &amp;ndash; 如果没有缓存过，获取执行方法的返回结果；如果缓存过，则直接从缓存中获取，不再执行方法。&lt;/li&gt;
&lt;li&gt;@CacheEvict &amp;ndash; 如果设置了beforeIntercepte则在方法执行前进行缓存删除操作，如果没有，则在执行方法调用完后进行缓存删除操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;private Object execute(CacheOperationInvoker invoker, CacheOperationContexts contexts) {

	// 处理beforeIntercepte=true的缓存删除操作
	processCacheEvicts(contexts.get(CacheEvictOperation.class), true, ExpressionEvaluator.NO_RESULT);

	// 从缓存中查找，是否有匹配@Cacheable的缓存数据
	Cache.ValueWrapper cacheHit = findCachedItem(contexts.get(CacheableOperation.class));

	// 如果@Cacheable没有被缓存，那么就需要将数据缓存起来，这里将@Cacheable操作收集成CachePutRequest集合，以便后续做@CachePut缓存数据存放。
	List&amp;lt;CachePutRequest&amp;gt; cachePutRequests = new LinkedList&amp;lt;CachePutRequest&amp;gt;();
	if (cacheHit == null) {
		collectPutRequests(contexts.get(CacheableOperation.class), ExpressionEvaluator.NO_RESULT, cachePutRequests);
	}

	Cache.ValueWrapper result = null;

	// 如果没有@CachePut操作，就使用@Cacheable获取的结果（可能也没有@Cableable，所以result可能为空）。
	// hasCachePut(contexts)判断是否有可缓存的操作，这里处理了@Cacheable、@CachePut中unless否决缓存的情况，关于unless后面会分析到。
	if (cachePutRequests.isEmpty() &amp;amp;&amp;amp; !hasCachePut(contexts)) {
		result = cacheHit;
	}

	// 1. 既然从缓存中没有获取到数据，那么就执行方法内容吧。
	// 2. 如果有@CachePut，那么result肯定为null，所以@CachePut操作之前，肯定会先调用执行方法内容。
	// 3. 如果执行了方法，那么这里的result就是执行方法返回的结果。
	if (result == null) {
		result = new SimpleValueWrapper(invokeOperation(invoker));
	}

	// 收集@CachePut操作
	collectPutRequests(contexts.get(CachePutOperation.class), result.get(), cachePutRequests);

	// 处理@CachePut操作，将数据result数据存放到缓存中去。
	for (CachePutRequest cachePutRequest : cachePutRequests) {
		cachePutRequest.apply(result.get());
	}

	// 处理一般的@CacheEvict缓存删除操作情况，也就是beforeIntercepte=false的情况。
	processCacheEvicts(contexts.get(CacheEvictOperation.class), false, result.get());

	//返回方法执行的返回结果
	return result.get();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
上面已经分析了@CachePut、@Cacheable、@CacheEvict注解功能的具体功能实现，Spring Cache的功能基本已经了解的差不多了。但是，我们从之前的CacheOperation、CacheAnnotationParser、CacheAnnotationSource、CacheInterceptor一路分析过来，但是还是发现少了些什么。不禁会想CacheManager和Cache在哪里？唯独缺少了我们在applicationContext.xml中配置的CacheManager和Cache。我们抱着打破沙锅问到底的学习目的，下面接下来看看缓存对象Cache的获取。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;缓存对象cache的获取&#34;&gt;缓存对象Cache的获取&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
首先我们先整理一下上面的CacheAspectSupport#execute(CacheOperationInvoker invoker, CacheOperationContexts contexts)这个方法中出现过的类。CacheOperationContexts、CachePutRequest、CacheOperationContext等等。下面我们将对这些类对象也做下详细的分析。&lt;/p&gt;

&lt;h4 id=&#34;cacheoperationcontexts-获取具体的缓存操作类型&#34;&gt;CacheOperationContexts  获取具体的缓存操作类型&lt;/h4&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
前面提到过，CacheOperationContexts是对Collection&lt;CacheOperation&gt;缓存操作集合做的一次封装处理，目的是为了可以获得具体缓存操作。由于很简单，我们直接分析源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private class CacheOperationContexts {

	//保存每种类型缓存操作的上下文数据，Map中的key是CacheOperation类型，也就是@CachePut、@Cacheable、@CacheEvict对应的3中CacheOperation实现类型。
	//Map中的value是CacheOperationContext。另外注意，这个Map不是普通的Map，而是一个MultiValueMap，这种Map的key是可以重复存放的。
	private final MultiValueMap&amp;lt;Class&amp;lt;? extends CacheOperation&amp;gt;, CacheOperationContext&amp;gt; contexts =
			new LinkedMultiValueMap&amp;lt;Class&amp;lt;? extends CacheOperation&amp;gt;, CacheOperationContext&amp;gt;();

	public CacheOperationContexts(Collection&amp;lt;? extends CacheOperation&amp;gt; operations, Method method,
			Object[] args, Object target, Class&amp;lt;?&amp;gt; targetClass) {
		//获取每种CacheOperation类型的缓存操作集合，然后保存到Map中去。
		for (CacheOperation operation : operations) {
			this.contexts.add(operation.getClass(), getOperationContext(operation, method, args, target, targetClass));
		}
	}
	
	//根据CacheOperation类型，直接从Map中获取对应的缓存操作上下文集合
	//比如： oprationClass为CachePutOperation，那么就是获取的所有@CachePut注解对应的缓存操作的上下文集合
	public Collection&amp;lt;CacheOperationContext&amp;gt; get(Class&amp;lt;? extends CacheOperation&amp;gt; operationClass) {
		Collection&amp;lt;CacheOperationContext&amp;gt; result = this.contexts.get(operationClass);
		return (result != null ? result : Collections.&amp;lt;CacheOperationContext&amp;gt;emptyList());
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
既然通过CacheOperationContexts#get(oprationClass)方法返回的是Collection&lt;CacheOperationContext&gt;，那么，我们是不是应该了解下CacheOperationContext包含哪些信息呢？ 接下来分析CacheOperationContext。&lt;/p&gt;

&lt;h5 id=&#34;cacheoperationcontext-封装缓存参数信息-condition-unless处理&#34;&gt;CacheOperationContext  封装缓存参数信息， condition、unless处理&lt;/h5&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
CacheOperationContext这个类我们要好好地去研究下，为什么呢？ 因为它包含了缓存条件(conditions)的判断，以及缓存对象Cache的获取，这些都是我们在分析源码的时候比较关心的东西。为了更好地理解CacheOperationContext的含义，我们先从属性开始了解，CacheOperationContext提供了一下的属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//缓存操作对象的源数据对象，封装了CacheOperation、method、targetClass、keyGenerator、cacheResolve
//metadata中的属性是通过CacheOperation中的属性来设置的，也就是@CachePut(keyGeneraor=&amp;quot;kg&amp;quot;, cacheResolve=&amp;quot;cr&amp;quot;)
//这样就达到了自定义keyGeneraor的效果
private final CacheOperationMetadata metadata;

//执行方法的参数
private final Object[] args;

//执行方法的目标类对象
private final Object target;

//执行方法可以获取到的缓存对象集合，也就是@CachePut等设置的value值关联的那个Cache对象
private final Collection&amp;lt;? extends Cache&amp;gt; caches;

//执行方法使用缓存注解设置的缓存名称，例如:@CachePut(value=&amp;quot;cacheName&amp;quot;)
private final Collection&amp;lt;String&amp;gt; cacheNames;

//表示目标类型的执行方法标识的key值
private final AnnotatedElementKey methodCacheKey;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
接下来，我们看看CacheOperationContext中主要的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected class CacheOperationContext implements CacheOperationInvocationContext&amp;lt;CacheOperation&amp;gt; {

	public CacheOperationContext(CacheOperationMetadata metadata, Object[] args, Object target) {
		this.metadata = metadata;
		this.args = extractArgs(metadata.method, args);
		this.target = target;
		//获取缓存对象Cache
		this.caches = CacheAspectSupport.this.getCaches(this, metadata.cacheResolver);
		this.cacheNames = createCacheNames(this.caches);
		this.methodCacheKey = new AnnotatedElementKey(metadata.method, metadata.targetClass);
	}

	//这个方法用来判断缓存条件condition
	protected boolean isConditionPassing(Object result) {
		//首先判断CacheOperation是否设置了conditions条件
		//如果没有设置条件，则直接通过条件检测
		//如果设置了条件，那么通过evaluator去判断（ExpressionEvaluator evaluator 会通过SpEL表达式去检测）
		if (StringUtils.hasText(this.metadata.operation.getCondition())) {
			EvaluationContext evaluationContext = createEvaluationContext(result);
			return evaluator.condition(this.metadata.operation.getCondition(),
					this.methodCacheKey, evaluationContext);
		}
		return true;
	}

	//处理@Cacheable、@CachePut中unless，如果unless通过SpEL检测，则否决存放缓存
	protected boolean canPutToCache(Object value) {
		String unless = &amp;quot;&amp;quot;;
		if (this.metadata.operation instanceof CacheableOperation) {
			unless = ((CacheableOperation) this.metadata.operation).getUnless();
		}
		else if (this.metadata.operation instanceof CachePutOperation) {
			unless = ((CachePutOperation) this.metadata.operation).getUnless();
		}
		if (StringUtils.hasText(unless)) {
			EvaluationContext evaluationContext = createEvaluationContext(value);
			return !evaluator.unless(unless, this.methodCacheKey, evaluationContext);
		}
		return true;
	}

	/**
	 * Cache中的key值都是通过KeyGenerator来生成的，默认使用了SimpleKeyGenerator。
	 */
	protected Object generateKey(Object result) {
		if (StringUtils.hasText(this.metadata.operation.getKey())) {
			EvaluationContext evaluationContext = createEvaluationContext(result);
			return evaluator.key(this.metadata.operation.getKey(), this.methodCacheKey, evaluationContext);
		}
		//使用KeyGenerator生成Cache中的缓存key值
		return this.metadata.keyGenerator.generate(this.target, this.metadata.method, this.args);
	}

	//EvaluationContext对象用于SpEL表达式检测，关于SpEL不做深入分析
	private EvaluationContext createEvaluationContext(Object result) {
		return evaluator.createEvaluationContext(
				this.caches, this.metadata.method, this.args, this.target, this.metadata.targetClass, result);
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;cacheresolver-获取缓存对象cache&#34;&gt;CacheResolver 获取缓存对象Cache&lt;/h5&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在CacheOperationContext的构造方法中，使用了this.caches = CacheAspectSupport.this.getCaches(this, metadata.cacheResolver)来设置caches。我们看看CacheResolver是如何解析出Cache对象的。我们直接到AbstractCacheResolver#resolveCaches(CacheOperationInvocationContext&amp;lt;?&amp;gt; context)这个方法中去。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Collection&amp;lt;? extends Cache&amp;gt; resolveCaches(CacheOperationInvocationContext&amp;lt;?&amp;gt; context) {

	//获取缓存名称，默认使用SimpleCacheResolver，也就是获取@CachePut(value={&amp;quot;cacheName1&amp;quot;, &amp;quot;cacheName2&amp;quot;})注解中的值。
	Collection&amp;lt;String&amp;gt; cacheNames = getCacheNames(context);
	if (cacheNames == null) {
		return Collections.emptyList();
	}
	else {
		//通过缓存名称，从CacheManager中去找到关联的Cache对象。
		Collection&amp;lt;Cache&amp;gt; result = new ArrayList&amp;lt;Cache&amp;gt;();
		for (String cacheName : cacheNames) {
			Cache cache = this.cacheManager.getCache(cacheName);
			if (cache == null) {
				throw new IllegalArgumentException(&amp;quot;Cannot find cache named &#39;&amp;quot; +
						cacheName + &amp;quot;&#39; for &amp;quot; + context.getOperation());
			}
			result.add(cache);
		}
		return result;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
缓存对象Cache我们已经获取到了，接下来就应该可以调用缓存操作了吧，比如put(key,value)方法。 接下来我们继续分析CachePutRequest对象。&lt;/p&gt;

&lt;h5 id=&#34;cacheputrequest-缓存存放操作请求&#34;&gt;CachePutRequest  缓存存放操作请求&lt;/h5&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
CachePutRequest很简单，就是请求将方法返回结果result以key存放到缓存对象Cache中去，调用了doPut方法， 这是CacheInterceptor父类AbstractCacheInvoker提供的，很简单，就不贴源码了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private class CachePutRequest {

	private final CacheOperationContext context;

	private final Object key;

	public CachePutRequest(CacheOperationContext context, Object key) {
		this.context = context;
		this.key = key;
	}

	public void apply(Object result) {
		if (this.context.canPutToCache(result)) {
			for (Cache cache : this.context.getCaches()) {
				doPut(cache, this.key, result);
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
用了好几篇来讲述SpringCache是怎么处理@CachePut、@Cacheable、@CacheEvict操作的，按照我们之前的思路一路分析过来：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CacheOperation封装了@CachePut、@Cacheable、@CacheEvict的属性信息，以便于能够获得被拦截方法的缓存操作集合。&lt;/li&gt;
&lt;li&gt;CacheAnnotationParser将@CachePut、@Cacheable、@CacheEvict注解解析成CacheOperation集合。(也包含了对@Caching、@CacheConfig的解析)&lt;/li&gt;
&lt;li&gt;CacheAnnotationSource获取执行方法的缓存操作集合，这个获取的过程是委派给CacheAnnotationParser去做的。CacheAnnotationParser充当了解析注解的策略接口。&lt;/li&gt;
&lt;li&gt;CacheInterceptor实现了MethodInterceptor接口，在Spring AOP中实现对执行方法的拦截。在调用invoke方法时，是通过调用CacheAnnotationSource来获取缓存操作集合的。&lt;/li&gt;
&lt;li&gt;CacheInterceptor的父类CacheAspectSupport实现了@CachePut、@Cacheable、@CacheEvict的缓存功能。&lt;/li&gt;
&lt;li&gt;每一个缓存操作CacheOperation最后被封装成了CacheOperationContext，CacheOperationContext通过CacheResolver解析出缓存对象Cache。&lt;/li&gt;
&lt;li&gt;最后CacheInterceptor调用了超级父类AbstractCacheInvoker提供的缓存对象Cache的基本方法doPut、doGet、doEvict等方法来缓存数据。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
        <item>
            <title>SpringCache源码分析(3) @CachePut、@Cacheable、@CacheEvict注解解析</title>
            <link>http://www.xiaoqiyiye.com/2016/01/23/spring-cache-3/</link>
            <pubDate>Sat, 23 Jan 2016 22:18:00 &#43;0800</pubDate>
            <author>CoderZh</author>
            <guid>http://www.xiaoqiyiye.com/2016/01/23/spring-cache-3/</guid>
            <description>

&lt;hr /&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
从上一篇中我们提及到，既然方法使用了@CachePut、@Cacheable、@CacheEvict这些注解，那么，执行方法是怎么知道设置了哪些注解信息的呢？ 下面我们分析一下注解的解析。但，在分析之前我们需要知道缓存操作封装类CacheOperation。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;cacheoperation缓存操作封装类&#34;&gt;CacheOperation缓存操作封装类&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
CacheOperation抽象类表示缓存的基本操作，封装了缓存基本操作的一些属性信息，也就是在@CachePut、@Cacheable、@CacheEvict中配置的属性信息。CacheOperation有三个实现类，分别是CachePutOperation、CacheableOperation、CacheEvictOperation，不用说也知道这是对注解信息的封装类。下面简单的看一下CacheOperation封装了哪些信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public abstract class CacheOperation implements BasicOperation {

	private String name = &amp;quot;&amp;quot;;

	private Set&amp;lt;String&amp;gt; cacheNames = Collections.emptySet();

	private String key = &amp;quot;&amp;quot;;

	private String keyGenerator = &amp;quot;&amp;quot;;

	private String cacheManager = &amp;quot;&amp;quot;;

	private String cacheResolver = &amp;quot;&amp;quot;;

	private String condition = &amp;quot;&amp;quot;;

	/* 省略了一些setter、getter方法 */

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
这些属性是不是很熟悉，就是在配置@CachePut、@Cacheable、@CacheEvict使用的一些公共属性。CacheOperation没什么好分析的，我们只要知道最终注解信息都被转换成CacheOperation对象就可以了。至于是哪个具体的实现，我们现在还不用关心，后面会知道。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;cacheannotationparser缓存注解解析器&#34;&gt;CacheAnnotationParser缓存注解解析器&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
CacheAnnotationParser接口提供了2个方法，分别对类和方法上的注解进行解析。因为我们知道@CachePut可以在类或方法上进行注解。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
CacheAnnotationParser这是一个策略接口，它是委派给AnnotationCacheOperationSource来执行的，AnnotationCacheOperationSource内部持有一个CacheAnnotationParser集合，可以执行一系列的CacheAnnotationParser实现。也就是说我们可以自定义像@CachePut一样的注解，然后提供对应的CacheAnnotationParser解析器，达到我们自定义缓存功能的效果。下面是CacheAnnotationParser接口的源码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * CacheAnnotationParser是为解析注解提供的一个策略接口，AnnotationCacheOperationSource 会委派一些解析器来解析特定的注解类型，像Spring Cache的@Cacheable、@CachePut、@CacheEvict
 */
public interface CacheAnnotationParser {

	/**
     * 对给定类型上的缓存注解进行解析，如果没有则返回null
	 * @see AnnotationCacheOperationSource#findCacheOperations(Class)
	 */
	Collection&amp;lt;CacheOperation&amp;gt; parseCacheAnnotations(Class&amp;lt;?&amp;gt; type);

	/**
     * 对给定方法上的缓存注解进行解析，如果没有则返回null
	 * @see AnnotationCacheOperationSource#findCacheOperations(Method)
	 */
	Collection&amp;lt;CacheOperation&amp;gt; parseCacheAnnotations(Method method);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
那么@CachePut、@Cacheable、@CacheEvict到底是哪个类来解析的呢？ 就是，SpringCacheAnnotationParser。下面我们看看SpringCacheAnnotationParser是如何解析注解的，我们还是看看CacheAnnotationParser提供的接口方法，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public Collection&amp;lt;CacheOperation&amp;gt; parseCacheAnnotations(Class&amp;lt;?&amp;gt; type) {
	//获取@CacheConfig注解信息
	DefaultCacheConfig defaultConfig = getDefaultCacheConfig(type);
	//解析其他的缓存注解@Caching、@CachePut、@Cacheable、@CacheEvict
	return parseCacheAnnotations(defaultConfig, type);
}

@Override

public Collection&amp;lt;CacheOperation&amp;gt; parseCacheAnnotations(Method method) {
	DefaultCacheConfig defaultConfig = getDefaultCacheConfig(method.getDeclaringClass());
	return parseCacheAnnotations(defaultConfig, method);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
从上面的代码可以看出，这2个方法解析方式一样，都调用了相同的方法。第一，解析@CacheConfig注解，调用了getDefaultCacheConfig(Class&amp;lt;?&amp;gt; target)方法；第二，解析其他缓存注解，都调用了parseCacheAnnotations(DefaultCacheConfig cachingConfig, AnnotatedElement ae)这个方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;DefaultCacheConfig获取@CacheConfig注解信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; DefaultCacheConfig getDefaultCacheConfig(Class&amp;lt;?&amp;gt; target) {
    
    //直接获取目标类型上的@CacheConfig注解，如果有则将属性信息设置好，如果没有则给定一个默认的DefaultCacheConfig对象。
    CacheConfig annotation = AnnotationUtils.getAnnotation(target, CacheConfig.class);
    
    if (annotation != null) {
        return new DefaultCacheConfig(annotation.cacheNames(), annotation.keyGenerator(),
                annotation.cacheManager(), annotation.cacheResolver());
    }
    
    return new DefaultCacheConfig();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取CacheOperation集合信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected Collection&amp;lt;CacheOperation&amp;gt; parseCacheAnnotations(DefaultCacheConfig cachingConfig, AnnotatedElement ae) {
    
    Collection&amp;lt;CacheOperation&amp;gt; ops = null;
    
    //解析@Cacheable
    Collection&amp;lt;Cacheable&amp;gt; cacheables = getAnnotations(ae, Cacheable.class);
    if (cacheables != null) {
        ops = lazyInit(ops);
        for (Cacheable cacheable : cacheables) {
            ops.add(parseCacheableAnnotation(ae, cachingConfig, cacheable));
        }
    }
    
    //解析@CacheEvict
    Collection&amp;lt;CacheEvict&amp;gt; evicts = getAnnotations(ae, CacheEvict.class);
    if (evicts != null) {
        ops = lazyInit(ops);
        for (CacheEvict evict : evicts) {
            ops.add(parseEvictAnnotation(ae, cachingConfig, evict));
        }
    }
    
    //解析@CachePut
    Collection&amp;lt;CachePut&amp;gt; puts = getAnnotations(ae, CachePut.class);
    if (puts != null) {
        ops = lazyInit(ops);
        for (CachePut put : puts) {
            ops.add(parsePutAnnotation(ae, cachingConfig, put));
        }
    }
    
    //解析@Caching
    Collection&amp;lt;Caching&amp;gt; cachings = getAnnotations(ae, Caching.class);
    if (cachings != null) {
        ops = lazyInit(ops);
        for (Caching caching : cachings) {
            ops.addAll(parseCachingAnnotation(ae, cachingConfig, caching));
        }
    }
        
    //最后，返回解析出来的所有缓存操作对象CacheOperation集合
    return ops;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
这些代码虽然很简单，但是有些细节还是需要说明：
1. 如果存在自定义注解使用了@CachePut等这些缓存注解，该怎么解析呢？ 到底需不需解析到？
2. 前面说过@CachConfig是一个总注解配置，那么，@CacheConfig的注解信息如何优先于其他注解信息呢？
3. 在@CachePut、@Cacheable、@CacheEvict注解信息中，key和keyGenerator是排它性的，cacheManager和cacheResolve也是排它性的，为什么呢？&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
答案就在我们的眼前，下面我们看看 getAnnotations(AnnotatedElement ae, Class&lt;T&gt; annotationType) 和 parsePutAnnotation(AnnotatedElement ae, DefaultCacheConfig defaultConfig, CachePut cachePut) （三个方法之选一个说明，其他两个都一样）&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;自定义注解中存在-cacheput等缓存注解&#34;&gt;自定义注解中存在@CachePut等缓存注解&lt;/h4&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
假设我们自定以了一个注解类型@UserCache，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Cacheable(value=&amp;quot;user&amp;quot;)
public @interface UserCache{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
如果一个方法使用了@UserCache，那么，@UserCache中使用的@Cacheable是否也应该包含该方法的缓存注解解析中去呢？ 答案是肯定的，需要包含。但是如果注解层级关系不止一层，如果是二层注解关系，又会是怎样的呢？多层次的注解关系是不会被解析到的。下面看看getAnnotations()这个方法，分析如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private &amp;lt;T extends Annotation&amp;gt; Collection&amp;lt;T&amp;gt; getAnnotations(AnnotatedElement ae, Class&amp;lt;T&amp;gt; annotationType) {

	Collection&amp;lt;T&amp;gt; anns = new ArrayList&amp;lt;T&amp;gt;(2);

	//查找原生的注解
	T ann = ae.getAnnotation(annotationType);
	if (ann != null) {
		anns.add(AnnotationUtils.synthesizeAnnotation(ann, ae));
	}

	//扫描注解中的注解，注意：这里只包含了一层注解关系，如果出现多层次的注解关系是扫描不到的！
	for (Annotation metaAnn : ae.getAnnotations()) {
		ann = metaAnn.annotationType().getAnnotation(annotationType);
		if (ann != null) {
			anns.add(AnnotationUtils.synthesizeAnnotation(ann, ae));
		}
	}

	return (anns.isEmpty() ? null : anns);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;cacheconfig的高优先级别&#34;&gt;@CacheConfig的高优先级别&lt;/h4&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
前面早已说明过@CacheConfig的作用要高于@CachePut、@Cacheable、@CacheEvict，但是，为什么呢？这些也只能算是我们的道听途说。作为一个Coding，我们不要那些道听途说，别人说的不一定是对的。下面的代码会给你一个真理，让你也知道：哦，原来就是这么简单！ 我们就拿@CachePut的解析来说，下面是解析的方法。（@Cacheable、@CacheEvict一样就不赘述啦）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CacheOperation parsePutAnnotation(AnnotatedElement ae, DefaultCacheConfig defaultConfig, CachePut cachePut) {

	CachePutOperation op = new CachePutOperation();
	op.setCacheNames(cachePut.cacheNames());
	op.setCondition(cachePut.condition());
	op.setUnless(cachePut.unless());
	op.setKey(cachePut.key());
	op.setKeyGenerator(cachePut.keyGenerator());
	op.setCacheManager(cachePut.cacheManager());
	op.setCacheResolver(cachePut.cacheResolver());
	op.setName(ae.toString());

	//这里会去对op对象做一次重新的设定，到底做了什么，我想你会懂的！
	//这里会把@CacheConfig中配置的注解信息重新设置一边，也就是覆盖前面设置过的值。
	defaultConfig.applyDefault(op);
	validateCacheOperation(ae, op);

	return op;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;key和keygenerator-cachemanager和cacheresolve排它性&#34;&gt;key和keyGenerator、cacheManager和cacheResolve排它性&lt;/h4&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
从下面的代码中，很容易知道，如果key和keyGenerator、cacheManager和cacheResolve同时存在就会抛出异常了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void validateCacheOperation(AnnotatedElement ae, CacheOperation operation) {

	if (StringUtils.hasText(operation.getKey()) &amp;amp;&amp;amp; StringUtils.hasText(operation.getKeyGenerator())) {
		throw new IllegalStateException(&amp;quot;Invalid cache annotation configuration on &#39;&amp;quot; +
				ae.toString() + &amp;quot;&#39;. Both &#39;key&#39; and &#39;keyGenerator&#39; attributes have been set. &amp;quot; +
				&amp;quot;These attributes are mutually exclusive: either set the SpEL expression used to&amp;quot; +
				&amp;quot;compute the key at runtime or set the name of the KeyGenerator bean to use.&amp;quot;);
	}

	if (StringUtils.hasText(operation.getCacheManager()) &amp;amp;&amp;amp; StringUtils.hasText(operation.getCacheResolver())) {
		throw new IllegalStateException(&amp;quot;Invalid cache annotation configuration on &#39;&amp;quot; +
				ae.toString() + &amp;quot;&#39;. Both &#39;cacheManager&#39; and &#39;cacheResolver&#39; attributes have been set. &amp;quot; +
				&amp;quot;These attributes are mutually exclusive: the cache manager is used to configure a&amp;quot; +
				&amp;quot;default cache resolver if none is set. If a cache resolver is set, the cache manager&amp;quot; +
				&amp;quot;won&#39;t be used.&amp;quot;);
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
@CacheConfig、@Caching、@CachePut、@Cacheable、@CacheEvict这些缓存注解的解析分析完了，总结一句话，就是将缓存注解都解析成了Collection&amp;lt;CacheOperation&amp;gt;对象。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
解析成Collection&amp;lt;CacheOperation&amp;gt;对象，什么时候调用呢？ 前面提及过CacheAnnotationParser提供了对缓存注解的解析策略。具体的调用并不是由CacheAnnotationParser直接处理的，而是由AnnotationCacheOperationSource委派给CacheAnnotationParser来处理。AnnotationCacheOperationSource是CacheOperationSource接口的实现类，也就是说调用工作是由CacheOperationSource来负责的。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;cacheoperationsource-缓存操作调用&#34;&gt;CacheOperationSource 缓存操作调用&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
下面，我们直接了当地看CacheOperationSource接口的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**

 * 这个接口是由CacheInterceptor使用
 * Interface used by {@link CacheInterceptor}. Implementations know how to source
 */
public interface CacheOperationSource {

	/**
     * 方法功能很明确：为一个执行方法返回所有缓存注解的缓存操作集合
	 */
	Collection&amp;lt;CacheOperation&amp;gt; getCacheOperations(Method method, Class&amp;lt;?&amp;gt; targetClass);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
现在，我们的思路应该很清楚了。那就是，CacheInterceptor调用了CacheOperationSource，CacheOperationSource委派给CacheAnnotationParser去解析执行方法上的注解，然后返回一个Collection&lt;CacheOperation&gt;给CacheInterceptor。就是这样！&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
CacheInterceptor怎么调用了CacheOperationSource我们现在暂且不管，下一篇中分析。 下面，我们看看，CacheOperationSource如何委派CacheAnnotationParser解析注解。&lt;/p&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;annotationcacheoperationsource-委派给注解解析器&#34;&gt;AnnotationCacheOperationSource 委派给注解解析器&lt;/h5&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
AnnotationCacheOperationSource的继承关系是： AnnotationCacheOperationSource &amp;ndash;&amp;gt; AbstractFallbackCacheOperationSource &amp;ndash;&amp;gt; CacheOperationSource。所以我们还是先从AbstractFallbackCacheOperationSource开始分析，然后分析AnnotationCacheOperationSource。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
首先，看看AbstractFallbackCacheOperationSource提供的属性和实现CacheOperationSource的接口方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public abstract class AbstractFallbackCacheOperationSource implements CacheOperationSource {

	/**
	 * 这里的key是AnnotatedElementKey对象，这个对象只是对执行方法method和目标类型targetClass的包装。
	 * 也就是说，保证了method+targetClass产生key的唯一性。
	 */
	private final Map&amp;lt;Object, Collection&amp;lt;CacheOperation&amp;gt;&amp;gt; attributeCache =
			new ConcurrentHashMap&amp;lt;Object, Collection&amp;lt;CacheOperation&amp;gt;&amp;gt;(1024);

	/**
	 * 为调用的方法获取缓存属性，如果方法中找不到，则从类型中找。
	 */
	@Override
	public Collection&amp;lt;CacheOperation&amp;gt; getCacheOperations(Method method, Class&amp;lt;?&amp;gt; targetClass) {

		//获取key，也就是AnnotatedElementKey对象(当作一般的保证key唯一性标志就好了)
		Object cacheKey = getCacheKey(method, targetClass);

		//从Map中获取，如果获取不到，则进行解析
		Collection&amp;lt;CacheOperation&amp;gt; cached = this.attributeCache.get(cacheKey);

		if (cached != null) {
			return (cached != NULL_CACHING_ATTRIBUTE ? cached : null);
		}
		else {
			//解析执行方法的缓存操作集合
			Collection&amp;lt;CacheOperation&amp;gt; cacheOps = computeCacheOperations(method, targetClass);
			if (cacheOps != null) {
				if (logger.isDebugEnabled()) {
					logger.debug(&amp;quot;Adding cacheable method &#39;&amp;quot; + method.getName() + &amp;quot;&#39; with attribute: &amp;quot; + cacheOps);
				}
				this.attributeCache.put(cacheKey, cacheOps);
			}
			else {
				this.attributeCache.put(cacheKey, NULL_CACHING_ATTRIBUTE);
			}
			return cacheOps;
		}
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
上面的代码很容易明白：当一个方法执行时，会去解析该方法的缓存操作集合，解析后放入到attributeCache这个Map中去，以便下次直接获取。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
但是，是怎么计算一个执行方法的缓存操作集合呢？ 在computeCacheOperations(method, targetClass)这个类中，下面跟进去瞧瞧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private Collection&amp;lt;CacheOperation&amp;gt; computeCacheOperations(Method method, Class&amp;lt;?&amp;gt; targetClass) {

	// 判断no-public方法是否可以获取缓存操作集合，子类可以重写allowPublicMethodsOnly()方法，默认返回的是false。
	if (allowPublicMethodsOnly() &amp;amp;&amp;amp; !Modifier.isPublic(method.getModifiers())) {
		return null;
	}

	//方法可能是接口上的，所以需要去找到一个特定的方法。
	Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);
	specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);

	//首先，试着从方法上找缓存操作集合（这是一个抽象方法）
	Collection&amp;lt;CacheOperation&amp;gt; opDef = findCacheOperations(specificMethod);
	if (opDef != null) {
		return opDef;
	}

	//其次，再试着从类型上找缓存操作集合（这也是一个抽象方法）
	opDef = findCacheOperations(specificMethod.getDeclaringClass());
	if (opDef != null) {
		return opDef;
	}

	//如果前面都没有找到，并且specificMethod != method，则从原始执行方法method上去找
	if (specificMethod != method) {
		//先从方法上找
		opDef = findCacheOperations(method);
		if (opDef != null) {
			return opDef;
		}

		//最后，再从类型上找
		return findCacheOperations(method.getDeclaringClass());
	}
	
	return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
从上面的分析可以知道，AbstractFallbackCacheOperationSource做了2件事情：第一，增加了Map作为缓存，以便后续可以直接获取。第二，处理了方法fallback（备援）的情况。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
接下来，我们需要看看findCacheOperations(specificMethod)和findCacheOperations(specificMethod.getDeclaringClass())这两个抽象方法是怎么实现的了，不用到说，实现类就是AnnotationCacheOperationSource了。我们再想想，有一个接口提供了和这两个类似的方法，那就是CacheAnnotationParser接口。到这里，我们终于把CacheOperationSource和CacheAnnotationParser联系起来了。下面再看看代码是如何实现的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class AnnotationCacheOperationSource extends AbstractFallbackCacheOperationSource implements Serializable {

	//定义是否只用public方法可以被缓存操作
	private final boolean publicMethodsOnly;

	//缓存注解解析器集合
	private final Set&amp;lt;CacheAnnotationParser&amp;gt; annotationParsers;

	@Override
	protected Collection&amp;lt;CacheOperation&amp;gt; findCacheOperations(final Class&amp;lt;?&amp;gt; clazz) {
	
		//实际上就是遍历annotationParsers
		return determineCacheOperations(new CacheOperationProvider() {
			@Override
			public Collection&amp;lt;CacheOperation&amp;gt; getCacheOperations(CacheAnnotationParser parser) {
				return parser.parseCacheAnnotations(clazz);
			}
		});

	}

	@Override
	protected Collection&amp;lt;CacheOperation&amp;gt; findCacheOperations(final Method method) {

		return determineCacheOperations(new CacheOperationProvider() {
			@Override
			public Collection&amp;lt;CacheOperation&amp;gt; getCacheOperations(CacheAnnotationParser parser) {
				return parser.parseCacheAnnotations(method);
			}
		});

	}

	/**
	 * 这里就是在遍历CacheAnnotationParser集合了，最后把所有的Collection&amp;lt;CacheOperation&amp;gt;返回
	 */
	protected Collection&amp;lt;CacheOperation&amp;gt; determineCacheOperations(CacheOperationProvider provider) {

		Collection&amp;lt;CacheOperation&amp;gt; ops = null;
		for (CacheAnnotationParser annotationParser : this.annotationParsers) {
			Collection&amp;lt;CacheOperation&amp;gt; annOps = provider.getCacheOperations(annotationParser);
			if (annOps != null) {
				if (ops == null) {
					ops = new ArrayList&amp;lt;CacheOperation&amp;gt;();
				}
				ops.addAll(annOps);
			}
		}

		return ops;
	}

	/**
	 * 重写了父类的方法，可以配置no-public缓存操作
	 */
	@Override
	protected boolean allowPublicMethodsOnly() {
		return this.publicMethodsOnly;
	}

	/**
	 * 只是为了便于遍历调用CacheAnnotationParser
	 */
	protected interface CacheOperationProvider {
		Collection&amp;lt;CacheOperation&amp;gt; getCacheOperations(CacheAnnotationParser parser);
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;CacheAnnotationParser将@CachePut等注解解析成CacheOperation集合对象&lt;/li&gt;
&lt;li&gt;CacheOperationSource委派CacheAnnotationParser来获取解析到的CacheOperation集合&lt;/li&gt;
&lt;li&gt;CacheInterceptor调用CacheOperationSource&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在下一篇中我们继续分析CacheInterceptor的调用。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>SpringCache源码分析(2) @CachePut、@Cacheable、@CacheEvict、@Caching注解</title>
            <link>http://www.xiaoqiyiye.com/2016/01/23/spring-cache-2/</link>
            <pubDate>Sat, 23 Jan 2016 20:00:00 &#43;0800</pubDate>
            <author>CoderZh</author>
            <guid>http://www.xiaoqiyiye.com/2016/01/23/spring-cache-2/</guid>
            <description>

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在上一篇中我们讲解了CacheManager和Cache源码，学会了怎样使用注解进行缓存，但是对于@CachePut、@Cacheable、@CacheEvict这些注解没有提及到，这一篇中我们将对Spring Cache中提供的注解操作做一个详细的说明。
&lt;br&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;cacheput&#34;&gt;@CachePut&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
@CachePut表示需要存放缓存数据，可以在类或方法上进行注解，如果注解在类上，表示这个类的所有方法都使用了@CachePut。这个注解可以设置哪些信息呢？我们直接看源代码，因为源代码能从根本说明一切。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @CachePut可以注解类和方法，注解类时，表示整个类中的方法都注解了
 */	
@Target({ ElementType.METHOD, ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface CachePut {

	/**
	 * 定义存放的Cache名称，和下面的cacheNames一样
	 */
	@AliasFor(&amp;quot;cacheNames&amp;quot;)
	String[] value() default {};

	@AliasFor(&amp;quot;value&amp;quot;)
	String[] cacheNames() default {};

	/**
     * 为缓存值定义的key，默认为&amp;quot;&amp;quot;，表示所有的参数都加入到key的生成中（使用默认的keyGenerator）
	 */
	String key() default &amp;quot;&amp;quot;;

	/**
     * 可以使用keyGenerator来自定义key的生成，但是keyGenerator和key是排它性的，也就是说key和keyGenerator只能定义其中一个
	 */
	String keyGenerator() default &amp;quot;&amp;quot;;

	/**
     * 指定设置特定的cacheManager，与cacheResolver也是排它性的。
	 * {@link org.springframework.cache.CacheManager}
	 */
	String cacheManager() default &amp;quot;&amp;quot;;

	/**
     * 自定义cacheResolver
	 * {@link org.springframework.cache.interceptor.CacheResolver}
	 */
	String cacheResolver() default &amp;quot;&amp;quot;;

	/**
     * 定义缓存被存放的条件，只有满足条件的方法返回值才能被存放。默认为&amp;quot;&amp;quot;，也意味着方法的结果都可以被缓存。
	 */
	String condition() default &amp;quot;&amp;quot;;

	/**
     * unless是在方法调用后判断是否需要进行缓存更新，如果满足unless条件就不缓存。unless具有否决权！
	 */
	String unless() default &amp;quot;&amp;quot;;

}
```	


----------


### @Cacheable

&amp;amp;#160;&amp;amp;#160;&amp;amp;#160;&amp;amp;#160;
@Cacheable表示从缓存中取数据，如果缓存中没有数据则执行方法，并将方法返回的结果存入到缓存中，以便下次直接从缓存中获取。@Cacheable可以在类或方法上进行注解，如果注解在类上，表示这个类的所有方法都使用了@Cacheable。由于@Cacheable和@CachePut的定义一样，就不多说明了。

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Cacheable {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@AliasFor(&amp;quot;cacheNames&amp;quot;)
String[] value() default {};

@AliasFor(&amp;quot;value&amp;quot;)
String[] cacheNames() default {};

String key() default &amp;quot;&amp;quot;;

String keyGenerator() default &amp;quot;&amp;quot;;

String cacheManager() default &amp;quot;&amp;quot;;

String cacheResolver() default &amp;quot;&amp;quot;;

String condition() default &amp;quot;&amp;quot;;

String unless() default &amp;quot;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

----------

### @CacheEvict

&amp;amp;#160;&amp;amp;#160;&amp;amp;#160;&amp;amp;#160;
@CacheEvit表示从缓存中删除数据。和@CachePut、@Cacheable的定义基本一样，只有2个参数定义不同，allEntries和beforeInvocation。allEntries表示是否删除指定Cache名称中所有的缓存数据。beforeInvocation表示是否在方法执行前删除缓存数据，因为方法内部可能会出现异常，如果beforeInvocation=false,方法内出现异常，缓存中的数据是不会被删除的。

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface CacheEvict {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@AliasFor(&amp;quot;cacheNames&amp;quot;)
String[] value() default {};

@AliasFor(&amp;quot;value&amp;quot;)
String[] cacheNames() default {};

String key() default &amp;quot;&amp;quot;;

String keyGenerator() default &amp;quot;&amp;quot;;

String cacheManager() default &amp;quot;&amp;quot;;

String cacheResolver() default &amp;quot;&amp;quot;;

String condition() default &amp;quot;&amp;quot;;

/**
 * 表示是否删除缓存中所有数据，默认为false,只会删除与key关联的那个缓存数据
 */
boolean allEntries() default false;

/**
 * 表示是否在方法调用之前删除数据，默认为false，表示缓存删除操作是在方法调用之后的
 */
boolean beforeInvocation() default false;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

----------

### @Caching

&amp;amp;#160;&amp;amp;#160;&amp;amp;#160;&amp;amp;#160;
@Caching是一个组合式的注解，可以组合配置@CachePut、@Cacheable、@CacheEvict集合，也可以在类或方法上进行注解。

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Caching {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cacheable[] cacheable() default {};

CachePut[] put() default {};

CacheEvict[] evict() default {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
了解了@CachePut、@Cacheable、@CacheEvict这些注解的详细使用，那么，接下来我有一个疑惑了，这些注解到底是怎么作用到配置的方法上的呢？ 怎么能够说明一个执行方法就使用了这些注解呢？对，这些注解肯定需要被解析成操作对象！那么，@CachePut、@Cacheable、@CacheEvict会被怎么解析呢？ 这些问题我们在下一篇中做详细的分析。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>SpringCache源码分析(1)  CacheManager和Cache</title>
            <link>http://www.xiaoqiyiye.com/2016/01/23/spring-cache-1/</link>
            <pubDate>Fri, 22 Jan 2016 11:00:00 &#43;0800</pubDate>
            <author>CoderZh</author>
            <guid>http://www.xiaoqiyiye.com/2016/01/23/spring-cache-1/</guid>
            <description>

&lt;hr /&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
这篇作为Spring Cache源码分析的起始篇，重要在于分析CacheManager和Cache。但是，在分析CacheManager和Cache之前，还是先看一个简单的例子，这样有助于理解Spring Cache的概念，知道Spring Cache在干什么，有什么作用，只有知道了Spring Cache的用处，在分析源码的时候才能知道Spring Cache的功能是怎么实现的！ 这里不讲使用的细节，如果想要了解细节请看其他质料或后面篇章中的详细分析。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;hello示例-下载-https-github-com-xiaoqiyiye-blog-example-tree-master-seven-xiaoqiyiye-spring-cache-hello&#34;&gt;Hello示例 &lt;a href=&#34;https://github.com/xiaoqiyiye/blog-example/tree/master/seven.xiaoqiyiye.spring.cache.hello&#34;&gt;下载&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
下面直接上示例代码，一个简单的Hello程序，Hello、HelloService、HelloTest。在下面代码中我们用到了注解：@CachePut，@Cacheable，@CacheEvict。从单词意思我们就应该知道这些的作用是什么，@CachePut用于把数据存放到缓存中；@Cacheable用于从缓存中获取数据，如果缓存中不存在就执行代码得到并存放在缓存中去，以便下次从缓存中获取；@CacheEvict用于驱除缓存中的数据。在后面的章节中会详细的讲解这些注解中的每个属性。&lt;/p&gt;

&lt;p&gt;Hello对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Hello {
	String name;
	public Hello(String name){
		this.name = name;
	}
	public String getName() {
		return name;
	}
	@Override
	public String toString() {
		return &amp;quot;Hello,&amp;quot; + name;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HelloService对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Service
public class HelloService {
	/**
	 * 以Hello#name属性域作为缓存key（不管缓存是否存在，都会去执行）
	 * @param hello
	 * @return
	 */
	@CachePut(value=&amp;quot;hello&amp;quot;, key=&amp;quot;#hello.name&amp;quot;)
	public Hello put(Hello hello){
		System.out.println(&amp;quot;put Hello:&amp;quot; + hello.getName());
		return hello;
	}

	/**
	 * 以name参数为key
	 * 如果缓存中没有，则执行代码并缓存
	 * 如果缓存中已经存在，则直接从缓存中获取
	 * @param name
	 * @return
	 */
	@Cacheable(value=&amp;quot;hello&amp;quot;, key=&amp;quot;#name&amp;quot;)
	public Hello get(String name){
		System.out.println(&amp;quot;new Hello:&amp;quot; + name);
		return new Hello(name);
	}

	/**
	 * 从命名为&amp;quot;hello&amp;quot;的缓存中，删除掉name参数的key
	 * @param name
	 */
	@CacheEvict(value=&amp;quot;hello&amp;quot;, key=&amp;quot;#name&amp;quot;)
	public void remove(String name){
		System.out.println(&amp;quot;remove Hello:&amp;quot; + name);
	}

	/**
	 * 从命名为&amp;quot;hello&amp;quot;的缓存中，删除所有缓存
	 */
	@CacheEvict(value=&amp;quot;hello&amp;quot;, allEntries=true)
	public void removeAll(){
		System.out.println(&amp;quot;remove all!&amp;quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HelloTest测试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations=&amp;quot;classpath:applicationContext.xml&amp;quot;)
public class HelloTest extends AbstractJUnit4SpringContextTests{

	@Test
	public void hello(){
		HelloService service = applicationContext.getBean(HelloService.class);
		service.get(&amp;quot;linya&amp;quot;);
		Hello hello = service.get(&amp;quot;linya&amp;quot;);
		System.out.println(hello.toString());
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以试着运行上面的测试文件，但是程序是不能运行的，为什么呢，因为需要配置文件applicationContext.xml。上面我们说过通过注解可以缓存、获取、删除数据，那么数据被缓存到了哪里呢？很显然这样需要applicationContext.xml配置文件来处理，指明数据需要缓存的地方，这个缓存的地方在Spring Cache被定义为Cache和CacheManager，下面我们来看看如何简单的配置Spring Cache。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
	xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
	xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
	xmlns:cache=&amp;quot;http://www.springframework.org/schema/cache&amp;quot;
	xsi:schemaLocation=&amp;quot;
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans-4.1.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context-4.1.xsd
        http://www.springframework.org/schema/cache
        http://www.springframework.org/schema/cache/spring-cache-4.1.xsd&amp;quot;
	default-lazy-init=&amp;quot;true&amp;quot;&amp;gt;
	&amp;lt;context:component-scan base-package=&amp;quot;seven.xiaoqiyiye.spring.cache&amp;quot;/&amp;gt;
    &amp;lt;context:annotation-config/&amp;gt;
    
	&amp;lt;!-- SpringCache驱动一定要配置，后面会详细讲解这个配置的作用 --&amp;gt;
    &amp;lt;cache:annotation-driven/&amp;gt;

	&amp;lt;!-- 配置CacheManager，CacheManager中管理着Cache集合，在这里配置了一个名称为&amp;quot;hello&amp;quot;的Cache--&amp;gt;
	&amp;lt;bean id=&amp;quot;cacheManager&amp;quot; class=&amp;quot;org.springframework.cache.support.SimpleCacheManager&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;caches&amp;quot;&amp;gt;
            &amp;lt;set&amp;gt;
                &amp;lt;bean class=&amp;quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&amp;quot;&amp;gt;
                    &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;hello&amp;quot;/&amp;gt;
                &amp;lt;/bean&amp;gt;
            &amp;lt;/set&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;cachemanager-和-cache&#34;&gt;CacheManager 和 Cache&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
CacheManager定义很简单，用于管理Cache集合，并提供通过Cache名称获取对应Cache对象的方法。下面是CacheManager接口定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Spring&#39;s central cache manager SPI.
 * Allows for retrieving named {@link Cache} regions.
 * CacheManager可以通过名称来获取一个Cache对象
 * @author Costin Leau
 * @since 3.1
 */
public interface CacheManager {

	/**
	 * 通过name来获取Cache对象
	 */
	Cache getCache(String name);
	
	/**
     * 返回这个CacheManager管理的Cache集合的所有Cache名称
	 */
	Collection&amp;lt;String&amp;gt; getCacheNames();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
从上面的CacheManager可以知道，每个Cache必须要指定一个name，这个name需要在CacheManager中是唯一的。另外Cache对象还需要支持一些数据操作，存放数据、获取数据、驱除数据等等。下面，我们看看Cache接口的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Interface that defines common cache operations.
 */
public interface Cache {

	/**
     * 获取该Cache的名称
	 */
	String getName();

	/**
     * 返回底层真是的缓存对象，接口中并不需要关系具体是怎么实现的，
     * 使用Map、Reids、Guava，Ecache等
	 */
	Object getNativeCache();

	/**
     * 返回被包装的值，主要是为了null的处理
	 */
	ValueWrapper get(Object key);

	/**
     * 返回缓存中指定key的值，并获得这个值的特定类型
	 */
	&amp;lt;T&amp;gt; T get(Object key, Class&amp;lt;T&amp;gt; type);

	/**
     * 存放key-value数据到缓存中
	 */
	void put(Object key, Object value);

	ValueWrapper putIfAbsent(Object key, Object value);

	/**
     * 从缓存中删除指定key的数据
	 */
	void evict(Object key);

	/**
     * 删除缓存中所有数据
	 * Remove all mappings from the cache.
	 */
	void clear();

	interface ValueWrapper {
		Object get();
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
CacheManager和Cache接口定义就是这么简单，下面再看看CacheManager和Cache的实现类。它们的实现类很多，我们这里选基于ConcurrentMap的实现：ConcurrentMapCacheManager和ConcurrentMapCache。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * ConcurrentMapCacheManager负责管理ConcurrentMapCache对象，支持懒加载获取，也支持预先实例化对象，
 * 通过调用#setCacheNames方法可以预定义一些ConcurrentMapCache到ConcurrentMapCacheManager中，
 * 但是一旦设置过后，dynamic就会设置为false，这时就不再支持动态创建Cache功能。
 *
 * 通常是否懒加载可以通过不同的构造器来控制，new ConcurrentMapCacheManager()创建懒加载的CacheManager，
 * new ConcurrentMapCacheManager(String... cacheNames)创建预先定义Cache的CacheManager。
 */
public class ConcurrentMapCacheManager implements CacheManager {
	
	//使用ConcurrentMap来管理Cache集合对象
	private final ConcurrentMap&amp;lt;String, Cache&amp;gt; cacheMap = new ConcurrentHashMap&amp;lt;String, Cache&amp;gt;(16);
	//表示是否可以动态创建Cache缓存，如果指定过name那么就不能动态创建
	private boolean dynamic = true;
	
	public ConcurrentMapCacheManager() {
	}

	public ConcurrentMapCacheManager(String... cacheNames) {
		setCacheNames(Arrays.asList(cacheNames));
	}
	
	/**
     * 这里会初始化ConcurrentMapCache，并存放到ConcurrentMap中进行管理
     * 一旦初始化过，这dynamic=false，在调用getCache(name)是就不会动态创建了
	 */
	public void setCacheNames(Collection&amp;lt;String&amp;gt; cacheNames) {
		if (cacheNames != null) {
			for (String name : cacheNames) {
				this.cacheMap.put(name, createConcurrentMapCache(name));
			}
			this.dynamic = false;
		}
		else {
			this.dynamic = true;
		}
	}

	@Override
	public Collection&amp;lt;String&amp;gt; getCacheNames() {
		return Collections.unmodifiableSet(this.cacheMap.keySet());
	}

	/**
	 * 根据缓存name来获取关联的ConcurrentMapCache实例
	 * 如果ConcurrentMapCacheManager中没有获取到，则动态获取。（能否动态获取需要看dynamic是否为true）
	 */
	@Override
	public Cache getCache(String name) {
		Cache cache = this.cacheMap.get(name);
		if (cache == null &amp;amp;&amp;amp; this.dynamic) {
			synchronized (this.cacheMap) {
				cache = this.cacheMap.get(name);
				if (cache == null) {
					cache = createConcurrentMapCache(name);
					this.cacheMap.put(name, cache);
				}
			}
		}
		return cache;
	}

	/**
	 * 创建Cache对象
	 */
	protected Cache createConcurrentMapCache(String name) {
		return new ConcurrentMapCache(name, isAllowNullValues());
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
CacheManager和Cache是不是很简单？是的，非常简单！ 可是在上面的applicationContext.xml并没有配置ConcurrentMapCacheManager和ConcurrentMapCache呀，在回顾一下applicationContext.xml中是怎么配置的吧，配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;cacheManager&amp;quot; class=&amp;quot;org.springframework.cache.support.SimpleCacheManager&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;caches&amp;quot;&amp;gt;
        &amp;lt;set&amp;gt;
            &amp;lt;bean class=&amp;quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;hello&amp;quot;/&amp;gt;
            &amp;lt;/bean&amp;gt;
        &amp;lt;/set&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在applicationContext.xml中配置了SimpleCacheManager和ConcurrentMapCacheFactoryBean，SimpleCacheManager也是一个CacheManager的实现类，一个比ConcurrentMapCacheManager更简单的实现类，它需要外部指定Cache集合对象，而这个Cache对象正是使用ConcurrentMapCacheFactoryBean来注入到Spring的。虽然这两个类很简单，但是还是看一下部分源码吧（去掉了一些方法）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ConcurrentMapCacheFactoryBean implements FactoryBean&amp;lt;ConcurrentMapCache&amp;gt;, BeanNameAware, InitializingBean {

	//定义Cache的名称
	private String name = &amp;quot;&amp;quot;;

	//注入到Spring时缓存存储的数据
	private ConcurrentMap&amp;lt;Object, Object&amp;gt; store;

	//是否允许null值
	private boolean allowNullValues = true;

	//真实的Cache实现类

	private ConcurrentMapCache cache;


	/**
	 * Specify the name of the cache.
	 * &amp;lt;p&amp;gt;Default is &amp;quot;&amp;quot; (empty String).
	 */
	public void setName(String name) {
		this.name = name;
	}

	public void setStore(ConcurrentMap&amp;lt;Object, Object&amp;gt; store) {
		this.store = store;
	}

	public void setAllowNullValues(boolean allowNullValues) {
		this.allowNullValues = allowNullValues;
	}

	/**
	 * 以Spring注入的beanName作为Cache的名称
	 */
	@Override
	public void setBeanName(String beanName) {
		if (!StringUtils.hasLength(this.name)) {
			setName(beanName);
		}
	}

	/**
	 * 对象注入到Spring的时候就初始化好了Cache对象（ConcurrentMapCache）
	 */
	@Override
	public void afterPropertiesSet() {
		this.cache = (this.store != null ? new ConcurrentMapCache(this.name, this.store, this.allowNullValues) :
				new ConcurrentMapCache(this.name, this.allowNullValues));
	}

	@Override
	public ConcurrentMapCache getObject() {
		return this.cache;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
其实，在applicationContext.xml中就负责配置了CacheManager，告诉Spring Cache使用什么要的CacheManager实现，接下来我们使用ConcurrentMapCacheManager来配置，可以达到同样的效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;cacheManager&amp;quot; class=&amp;quot;org.springframework.cache.concurrent.ConcurrentMapCacheManager&amp;quot;&amp;gt;
    &amp;lt;!-- 可以不设置cacheNames哦，设置之后就不能动态创建Cache了。前面代码已经分析过，明白了吗！ --&amp;gt;
    &amp;lt;property name=&amp;quot;cacheNames&amp;quot;&amp;gt;
    	&amp;lt;set&amp;gt;
    		&amp;lt;value&amp;gt;hello&amp;lt;/value&amp;gt;
    		&amp;lt;value&amp;gt;world&amp;lt;/value&amp;gt;
    	&amp;lt;/set&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
通过上面的分析，我们已经清楚地了解了CacheManager和Cache接口的作用，以及基于ConcurrentMap的实现。但是，分析了这么久，那Spring到底是怎么缓存数据的呢？ @CachePut、@Cacheable、@CacheEvict是怎么产生作用的呢？ 莫急，莫急，这个在后续章节中详细说明。至少我们现在知道，数据被存储到哪里去了！ 对，数据被存储在Cache是实现类里，就这么简单！&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
CacheManager和Cache还有基于Redis、Guava、EhCache、JCache的实现，这里就不分析了。哈哈，其实原理都一样！&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>SpringMVC源码分析(3) HandlerMapping分析</title>
            <link>http://www.xiaoqiyiye.com/2015/10/22/spring/handlermapping</link>
            <pubDate>Sat, 24 Oct 2015 20:20:51 &#43;0800</pubDate>
            <author>CoderZh</author>
            <guid>http://www.xiaoqiyiye.com/2015/10/22/spring/handlermapping</guid>
            <description>

&lt;hr /&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在前面的篇章中我们已经提及过HandlerMapping接口，HandlerMapping接口提供的方法很简单，就是创建HandlerExecutorChain对象。而在HandlerExecutorChain对象中包含了handler对象和拦截器链对象。所以，我们在分析HandlerMapping过程中，也主要围绕这两点分析。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
由于HandlerMapping提供了最基本的抽象实现AbstractHandlerMapping，所以我们从AbstractHandlerMapping开始分析。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-abstracthandlermapping-分析&#34;&gt;1.AbstractHandlerMapping 分析&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
关于AbstractHandlerMapping的分析，分为以下三个步骤：
1. 属性域说明
2. 获取拦截器
3. 创建HandlerExecutorChain对象&lt;/p&gt;

&lt;h4 id=&#34;1-1-属性域说明&#34;&gt;1.1 属性域说明&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// 配置默认的handler对象，在没有获取到handler的情况下使用
private Object defaultHandler;

// request请求路径解析辅助类
private UrlPathHelper urlPathHelper = new UrlPathHelper();

// 请求路径匹配辅助类，用于匹配哪些路径可以被MappedInterceptor来拦截处理
private PathMatcher pathMatcher = new AntPathMatcher();

// 子类或配置文件可以配置拦截器，这里的Object类型为：
// HandlerInterceptor, WebRequestInterceptor 和 MappedInterceptor
private final List&amp;lt;Object&amp;gt; interceptors = new ArrayList&amp;lt;Object&amp;gt;();

// 请求真正被适配到的拦截器(包含了HandlerInterceptor, WebRequestInterceptor)
private final List&amp;lt;HandlerInterceptor&amp;gt; adaptedInterceptors = new ArrayList&amp;lt;HandlerInterceptor&amp;gt;();

// 需要进行路径匹配的MappingInterceptor
private final List&amp;lt;MappedInterceptor&amp;gt; mappedInterceptors = new ArrayList&amp;lt;MappedInterceptor&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-2-获取拦截器&#34;&gt;1.2 获取拦截器&lt;/h4&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
由于AbstractHandlerMapping继承了WebApplicationObjectSupport类，所以在Spring容器启动完成后会调用initApplicationContext()方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void initApplicationContext() throws BeansException {
    
    // 钩子方法，由子类重写，子类可以添加新的拦截器，
    // interceptors是由配置文件设置的，在Bean注入时调用setInterceptors(Object[] interceptors)注入。
	extendInterceptors(this.interceptors);
	
	// 检测容器中注入的MappedInterceptor，并添加到mappedInterceptors中。
	detectMappedInterceptors(this.mappedInterceptors);
	
	//初始化拦截器，也就对interceptors中的拦截器分类存放，
	// MappedInterceptor拦截器存放到mappedInterceptors中去，
	// HandlerInterceptor、WebRequestInterceptor拦截器存放到adaptedInterceptors中去。
	initInterceptors();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
下面是initInterceptors()的具体实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void initInterceptors() {
	if (!this.interceptors.isEmpty()) {
		for (int i = 0; i &amp;lt; this.interceptors.size(); i++) {
			Object interceptor = this.interceptors.get(i);
			if (interceptor == null) {
				throw new IllegalArgumentException();
			}
			// 存在到mappedInterceptors
			if (interceptor instanceof MappedInterceptor) {
				mappedInterceptors.add((MappedInterceptor) interceptor);
			}
			// 存放到adaptedInterceptors
			else {
				adaptedInterceptors.add(adaptInterceptor(interceptor));
			}
		}
	}
}
protected HandlerInterceptor adaptInterceptor(Object interceptor) {
	if (interceptor instanceof HandlerInterceptor) {
		return (HandlerInterceptor) interceptor;
	}
	// WebRequestInterceptor接口会被适配成HandlerInterceptor接口
	else if (interceptor instanceof WebRequestInterceptor) {
		return new WebRequestHandlerInterceptorAdapter((WebRequestInterceptor) interceptor);
	}
	else {
		throw new IllegalArgumentException(&amp;quot;Interceptor type not supported: &amp;quot; + interceptor.getClass().getName());
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-3-创建handlerexecutorchain对象&#34;&gt;1.3 创建HandlerExecutorChain对象&lt;/h4&gt;

&lt;p&gt;很清楚，创建HandlerExecutorChain对象是接口方法 HandlerExecutionChain getHandler(HttpServletRequest request)，下面直接分析代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
    // 这是一个抽象方法，具体的handler对象，子类去提供，因为抽象类并不知道是请求需要哪种handler
	Object handler = getHandlerInternal(request);
	// 如果没有获取到，则获取默认配置的handler
	if (handler == null) {
		handler = getDefaultHandler();
	}
	// 如果没有默认配置，则返回null
	if (handler == null) {
		return null;
	}
	// 如果handler是String类型，则当作beanName从容器器获取
	if (handler instanceof String) {
		String handlerName = (String) handler;
		handler = getApplicationContext().getBean(handlerName);
	}
	// 返回HandlerExecutionChain对象
	return getHandlerExecutionChain(handler, request);
}

protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {
    // 如果handler本身是HandlerExecutionChain类型则不用创建，
    // 否则创建一个HandlerExecutionChain对象并设置handler
	HandlerExecutionChain chain =
		(handler instanceof HandlerExecutionChain) ?
			(HandlerExecutionChain) handler : new HandlerExecutionChain(handler);
    
    // 设置拦截器
	chain.addInterceptors(getAdaptedInterceptors());

    // 根据请求路径，匹配哪些MappedInterceptor需要被拦截
	String lookupPath = urlPathHelper.getLookupPathForRequest(request);
	for (MappedInterceptor mappedInterceptor : mappedInterceptors) {
		if (mappedInterceptor.matches(lookupPath, pathMatcher)) {
			chain.addInterceptor(mappedInterceptor.getInterceptor());
		}
	}
    
    // 返回最终的HandlerExecutionChain对象
	return chain;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
上面通过三个方面分析了AbstractHandlerMapping，我们明白了拦截器是怎么获取的，我们也明白了HandlerExecutionChain的创建过程。AbstractHandlerMapping抽象类几乎做完了HandlerMapping接口的所有事情，只是handler对象的获取留给了子类去自由发挥。接下来，我们需要看看子类都是如何创建handler对象的&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
我们知道如果在配置文件中没有配置HandlerMapping，那么，SpringMVC会根据DispatcherServlet.properties中的配置来获取HandlerMapping的实现类。在DispatcherServlet.properties中配置了两个HandlerMapping实现类BeanNameUrlHandlerMapping和DefaultAnnotationHandlerMapping。接下来我们根据这两个类，来讲解handler的获取。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
BeanNameUrlHandlerMapping和DefaultAnnotationHandlerMapping都是基于URL的HandlerMapping，而且继承关系都是： AbstractDetectingUrlHandlerMapping &amp;ndash;&amp;gt; AbstractUrlHandlerMapping。 所以我们接下来分析基于URL的HandlerMapping。&lt;/p&gt;

&lt;h3 id=&#34;2-abstracturlhandlermapping分析&#34;&gt;2.AbstractUrlHandlerMapping分析&lt;/h3&gt;

&lt;h4 id=&#34;2-1-基于url匹配handler的过程&#34;&gt;2.1 基于URL匹配handler的过程&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;protected Object getHandlerInternal(HttpServletRequest request) throws Exception {
    // 获取请求路径
	String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);
	// 查找handler对象
	Object handler = lookupHandler(lookupPath, request);
	if (handler == null) {
		Object rawHandler = null;
		// 处理根路径，获取配置的rootHandler
		if (&amp;quot;/&amp;quot;.equals(lookupPath)) {
			rawHandler = getRootHandler();
		}
		if (rawHandler == null) {
			rawHandler = getDefaultHandler();
		}
		if (rawHandler != null) {
		    // 如果是String类型，则从容器中根据beanName获取
			if (rawHandler instanceof String) {
				String handlerName = (String) rawHandler;
				rawHandler = getApplicationContext().getBean(handlerName);
			}
			// 钩子方法子类去校验
			validateHandler(rawHandler, request);
			// 使用配置的rawHandler，来创建HandlerExecutionChain，把HandlerExecutionChain当作handler
			handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, null);
		}
	}
	// 返回handler
	return handler;
}

protected Object lookupHandler(String urlPath, HttpServletRequest request) throws Exception {
	// 直接使用路径获取handler，那么，handlerMap中的数据是怎么来的？ 后面再分析。
	Object handler = this.handlerMap.get(urlPath);
	if (handler != null) {
	    // 如果是String类型，则从容器中根据beanName获取
		if (handler instanceof String) {
			String handlerName = (String) handler;
			handler = getApplicationContext().getBean(handlerName);
		}
		// 钩子方法子类去校验
		validateHandler(handler, request);
		// 使用配置的rawHandler，来创建HandlerExecutionChain，把HandlerExecutionChain当作handler
		return buildPathExposingHandler(handler, urlPath, urlPath, null);
	}
    // 模糊匹配代码省略...
	// 如果最终没有匹配到，则放回null
	return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-2-handler注册&#34;&gt;2.2 handler注册&lt;/h4&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在上面分析过程中，我们不禁会问handlerMap中数据是怎么来的呢？ 这个问题也就是我们需要讲解的handler注册。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void registerHandler(String[] urlPaths, String beanName) throws BeansException, IllegalStateException {
	for (String urlPath : urlPaths) {
		registerHandler(urlPath, beanName);
	}
}

protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException {

	Object resolvedHandler = handler;
	
	// 是否设置懒加载
	if (!this.lazyInitHandlers &amp;amp;&amp;amp; handler instanceof String) {
		String handlerName = (String) handler;
		if (getApplicationContext().isSingleton(handlerName)) {
			resolvedHandler = getApplicationContext().getBean(handlerName);
		}
	}

    // 如果可以直接获取到，则判断和传入的resolvedHandler是否一致
	Object mappedHandler = this.handlerMap.get(urlPath);
	if (mappedHandler != null) {
		if (mappedHandler != resolvedHandler) {
			throw new IllegalStateException();
		}
	}
	else {
	    // 设置rootlHandler和defaultHandler
		if (urlPath.equals(&amp;quot;/&amp;quot;)) {
			setRootHandler(resolvedHandler);
		}
		else if (urlPath.equals(&amp;quot;/*&amp;quot;)) {
			setDefaultHandler(resolvedHandler);
		}
		else {
		    // 存放到handlerMap中
			this.handlerMap.put(urlPath, resolvedHandler);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在AbstractUrlHandlerMapping中，并没有调用registerHandler()方法，也就是说，只是提供了方法。而方法修饰符为protected，所以注册handler肯定是在子类进行的。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
AbstractUrlHandlerMapping的实现很简单，可以总结为以下两点：
1. 根据请求路径urlPath从handlerMap中获取handler，首先直接匹配，然后模糊匹配。
2. 提供注册handler的方法registerHandler()供子类来注册handler，存放到handlerMap中去。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
接下来可以分析AbstractDetectingUrlHandlerMapping了，从名称上我们就可以看出，这个抽象类是用来检测获取Url的。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;3-abstractdetectingurlhandlermapping分析&#34;&gt;3.AbstractDetectingUrlHandlerMapping分析&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
AbstractDetectingUrlHandlerMapping注册handler是通过重写initApplicationContext()来进行的，在Spring容器启动好后会调用detectHandlers()方法，AbstractDetectingUrlHandlerMapping就开始检测所有的Bean，并获取URL。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void detectHandlers() throws BeansException {
	// 获取容器中所有beanNames(配置detectHandlersInAncestorContexts可以从父容器检测，默认为false)
	String[] beanNames = (this.detectHandlersInAncestorContexts ?
			BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :
			getApplicationContext().getBeanNamesForType(Object.class));

	for (String beanName : beanNames) {
	    // 检测每一个beanName中的所有url(抽象方法，子类去实现如何查找urls)
		String[] urls = determineUrlsForHandler(beanName);
		if (!ObjectUtils.isEmpty(urls)) {
			// 注册handler
			registerHandler(urls, beanName);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
AbstractDetectingUrlHandlerMapping调用了registerHandler()来注册handler，最终都存放到AbstractUrlHandlerMapping#handlerMap中去。剩下的事情就是子类如何实现抽象方法determineUrlsForHandler(beanName)了。&lt;/p&gt;

&lt;h3 id=&#34;4-beannameurlhandlermapping分析&#34;&gt;4. BeanNameUrlHandlerMapping分析&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
BeanNameUrlHandlerMapping是基于beanName来获取Url，beanName必须以/开头。代码很简单，直接看代码了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected String[] determineUrlsForHandler(String beanName) {
	List&amp;lt;String&amp;gt; urls = new ArrayList&amp;lt;String&amp;gt;();
	// beanName需要以/开头
	if (beanName.startsWith(&amp;quot;/&amp;quot;)) {
		urls.add(beanName);
	}
	// 获取该beanName的别名，别名也需要以/开头
	String[] aliases = getApplicationContext().getAliases(beanName);
	for (String alias : aliases) {
		if (alias.startsWith(&amp;quot;/&amp;quot;)) {
			urls.add(alias);
		}
	}
	// 把匹配的路径全部返回
	return StringUtils.toStringArray(urls);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-defaultannotationhandlermapping分析&#34;&gt;4. DefaultAnnotationHandlerMapping分析&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
虽然DefaultAnnotationHandlerMapping在3.2版本以后就设置成了@Deprecated，也就是不建议使用这个了(RequestMappingHandlerMapping代替了它)。但我现在使用的4.0.2版本中DispatcherServlet.properties默认提供的还是DefaultAnnotationHandlerMapping，所以在我们不主动切换HandlerMapping的大多数情况下，我们还是会使用DefaultAnnotationHandlerMapping。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
DefaultAnnotationHandlerMapping的功能是从配置了@Controller、@RequestMapping的类中回去请求url。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected String[] determineUrlsForHandler(String beanName) {
	ApplicationContext context = getApplicationContext();
	Class&amp;lt;?&amp;gt; handlerType = context.getType(beanName);
	// 获取类型注解@RequestMapping
	RequestMapping mapping = context.findAnnotationOnBean(beanName, RequestMapping.class);
	if (mapping != null) {
		// 缓存类型上的@RequestMapping注解
		this.cachedMappings.put(handlerType, mapping);
		Set&amp;lt;String&amp;gt; urls = new LinkedHashSet&amp;lt;String&amp;gt;();
		// 获取@RequestMapping value值
		String[] typeLevelPatterns = mapping.value();
		if (typeLevelPatterns.length &amp;gt; 0) {
			// 获取方法上的@RequestMapping
			String[] methodLevelPatterns = determineUrlsForHandlerMethods(handlerType, true);
			// 结合类型上的@RequestMapping路径和方法上的@RequestMapping路径
			for (String typeLevelPattern : typeLevelPatterns) {
			    // 类型上@RequestMapping value值可以不用/开头，这里会检测
				if (!typeLevelPattern.startsWith(&amp;quot;/&amp;quot;)) {
					typeLevelPattern = &amp;quot;/&amp;quot; + typeLevelPattern;
				}
				// 方法上是否有空值的@RequestMapping
				boolean hasEmptyMethodLevelMappings = false;
				for (String methodLevelPattern : methodLevelPatterns) {
					if (methodLevelPattern == null) {
						hasEmptyMethodLevelMappings = true;
					}
					else {
					    // 获取结合后的url
						String combinedPattern = getPathMatcher().combine(typeLevelPattern, methodLevelPattern);
						addUrlsForPath(urls, combinedPattern);
					}
				}
				// 直接使用类型上的@RequestMapping，但需要时Controller对象类型
				if (hasEmptyMethodLevelMappings ||
						org.springframework.web.servlet.mvc.Controller.class.isAssignableFrom(handlerType)) {
					addUrlsForPath(urls, typeLevelPattern);
				}
			}
			return StringUtils.toStringArray(urls);
		}
		else {
			// 获取方法上的@RequestMapping
			return determineUrlsForHandlerMethods(handlerType, false);
		}
	}
	else if (AnnotationUtils.findAnnotation(handlerType, Controller.class) != null) {
		// 检测@Controller中的@RequestMapping
		return determineUrlsForHandlerMethods(handlerType, false);
	}
	else {
		return null;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
上面的方法有点复杂，就上面的方法我们归纳一下：
1. 检测类@RequestMapping和@Controller，@RequestMapping优先。如果存在@RequestMapping，则不会检测@Controller。
2. 如果类@RequestMapping存在，则和方法@RequestMapping组合在一起。如果存在方法@RequestMapping存在没有设置value，则以类@RequestMapping路径设置。
3. 如果没有类@RequestMapping，则检测类@Controller。注意@Controller(value=&amp;ldquo;name&amp;rdquo;)，@Controller中设置的value并不会影响请求url。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
下面我们在看看方法上的@RequestMapping是如何解析的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected String[] determineUrlsForHandlerMethods(Class&amp;lt;?&amp;gt; handlerType, final boolean hasTypeLevelMapping) {
    // 这是一个空方法，返回null，提供给子类自定义
	String[] subclassResult = determineUrlsForHandlerMethods(handlerType);
	if (subclassResult != null) {
		return subclassResult;
	}

	final Set&amp;lt;String&amp;gt; urls = new LinkedHashSet&amp;lt;String&amp;gt;();
	Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; handlerTypes = new LinkedHashSet&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;();
	// 添加handler以及所有接口
	handlerTypes.add(handlerType);
	handlerTypes.addAll(Arrays.asList(handlerType.getInterfaces()));
	// 遍历handler及其接口方法
	for (Class&amp;lt;?&amp;gt; currentHandlerType : handlerTypes) {
	    // 递归调用类以及父类方法（接口及父接口），排除bridge方法(编译器生成的方法)和Object方法
		ReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() {
			@Override
			public void doWith(Method method) {
			    // 获取方法@RequestMapping
				RequestMapping mapping = AnnotationUtils.findAnnotation(method, RequestMapping.class);
				if (mapping != null) {
				    // 获取路径值
					String[] mappedPatterns = mapping.value();
					if (mappedPatterns.length &amp;gt; 0) {
						for (String mappedPattern : mappedPatterns) {
						    //如果存在类@RequestMapping，则方法@RequestMapping必须以/开头
							if (!hasTypeLevelMapping &amp;amp;&amp;amp; !mappedPattern.startsWith(&amp;quot;/&amp;quot;)) {
								mappedPattern = &amp;quot;/&amp;quot; + mappedPattern;
							}
							addUrlsForPath(urls, mappedPattern);
						}
					}
					// 添加null
					else if (hasTypeLevelMapping) {
						urls.add(null);
					}
				}
			}
		}, ReflectionUtils.USER_DECLARED_METHODS);
	}
	return StringUtils.toStringArray(urls);
}	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
关于方法@RequestMapping我们也总结一下：
1. handler类，父类，接口，父接口中所有设置有@RequestMapping注解的方法都会处理。
2. 如果有类@RequestMapping，则方法@RequestMapping设置value时，必须以/开头，否则添加到路径集合中。如果是@Controller，则方法@RequestMapping可以不用/开头设置value。&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
1. HandlerMapping接口的功能是用来创建HandlerExecutionChain对象。而在创建过程中需要获取hander对象和拦截器。
2. 拦截器的获取是通过属性interceptors在配置文件中注入的。
3. handler对象的获取是根据请求url，从handlerMap中匹配。
4. handlerMap中的数据，是在Spring容器启动完成后进行设置。设置方式由子类完成。
5. 明白了BeanNameUrlHandlerMapping的设置。
6. 明白了@Controller、@RequestMapping注解配置的url是如何被读取的。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>SpringMVC源码分析(2) DispatchServlet请求分发</title>
            <link>http://www.xiaoqiyiye.com/2015/10/22/spring/</link>
            <pubDate>Thu, 22 Oct 2015 22:20:51 &#43;0800</pubDate>
            <author>CoderZh</author>
            <guid>http://www.xiaoqiyiye.com/2015/10/22/spring/</guid>
            <description>

&lt;hr /&gt;

&lt;h3 id=&#34;dispatchservlet请求分发&#34;&gt;DispatchServlet请求分发&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在上一篇中我们分析了DispatchServlet的启动过程，这篇中我们将要分析DispatchServlet的请求分发过程，也就是SpringMVC的工作原理。在分析代码之前，我们先了解一下SpringMVC的工作原理，如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/fxHZEhw.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;客户端发出请求给web服务器，web服务器对http请求进行解析，如果匹配DispatcherServlet的请求映射路径（在web.xml中指定），web容器将请求转交给DispatcherServlet。&lt;/li&gt;
&lt;li&gt;DipatcherServlet接收到这个请求之后，根据HandlerMapping的配置，找到处理请求的处理器（Handler），处理器对象是包装在HandlerExecutorChain中的。&lt;/li&gt;
&lt;li&gt;DispatcherServlet根据处理器去匹配到HandlerAdapter。&lt;/li&gt;
&lt;li&gt;DispatcherServlet根据HandlerMapping找到对应的Handler,将处理权交给Handler（Handler将具体的处理进行封装），再由具体的HandlerAdapter对Handler进行具体的调用。&lt;/li&gt;
&lt;li&gt;Handler对数据处理完成以后将返回一个ModelAndView()对象给DispatcherServlet。&lt;/li&gt;
&lt;li&gt;Handler返回的ModelAndView()只是一个逻辑视图并不是一个真实的视图，DispatcherSevlet通过ViewResolver将逻辑视图转化为真正的视图View。&lt;/li&gt;
&lt;li&gt;Dispatcher通过model解析出ModelAndView()中的参数进行解析最终展现出完整的view并返回给客户端。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;1-dispatchservlet请求入口&#34;&gt;1. DispatchServlet请求入口&lt;/h5&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
前面说过了，DispatchServlet是HttpServlet的子类，所以请求入口肯定是doService(request, response)方法。在doService(request, response)中将一些特殊的对象设置到request中，包括了webApplicationContext对象，然后调用doDispatch(request, response)做请求的分发。这个方法很简单，大致的看一下就OK了，在DispatcherServlet中最重要的方法是doDispatch(request, response)这个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {

    // 添加一些特殊的属性对象
	request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
	request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);
	request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
	request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());

	...省略一些代码

	try {
        //这个方法最重要，这是SpringMVC的核心，如何去处理请求分发？
		doDispatch(request, response);
	}
	finally {
		...省略一些代码
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
接下来，看看最重要的doDispatch(request, response)，这个方法是SpringMVC的中心调度器，负责处理交互各个对象。在这个方法中，我们要弄明白执行的主要步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;获取HandlerExecutorChain对象&lt;/li&gt;
&lt;li&gt;获取HandlerAdapter对象&lt;/li&gt;
&lt;li&gt;调用拦截器前置处理方法HandlerInterceptor#preHandle(&amp;hellip;)&lt;/li&gt;
&lt;li&gt;调用HandlerAdapter#handle(processedRequest, response, handler)，返回ModelAndView&lt;/li&gt;
&lt;li&gt;调用拦截器后置处理方法HandlerInterceptor#postHandle(&amp;hellip;)&lt;/li&gt;
&lt;li&gt;处理ModelAndView&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
	HttpServletRequest processedRequest = request;

	HandlerExecutionChain mappedHandler = null;
	boolean multipartRequestParsed = false;

	WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

	try {
		ModelAndView mv = null;
		Exception dispatchException = null;

		try {
		    // 判断是否是文件上传请求
			processedRequest = checkMultipart(request);
			multipartRequestParsed = processedRequest != request;

            // 控制器执行链对象HandlerExecutionChain，
            // 这个对象包含了处理器handler和拦截器集合interceptors，
			// SpringMVC拦截器的处理都是在这里面定义的。
            // HandlerExecutionChain对象由HandlerMapping接口来创建。
			mappedHandler = getHandler(processedRequest);
			if (mappedHandler == null || mappedHandler.getHandler() == null) {
				noHandlerFound(processedRequest, response);
				return;
			}

			// 通过hander去匹配一个处理handler操作的适配器HandlerAdapter对象
			HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

            // 调用拦截器链前置处理方法，如果拦截器链上返回了false，则请求结束。
			if (!mappedHandler.applyPreHandle(processedRequest, response)) {
				return;
			}

			try {
				// 由HandlerAdapter对象去真正调用处理器，
				// Controller里的方法就是在这里调用的，并返回一个ModelAndView对象
				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
			}
			finally {
				if (asyncManager.isConcurrentHandlingStarted()) {
					return;
				}
			}
            
            // 设置视图名称，这里需要用到ViewNameTranslator接口
			applyDefaultViewName(request, mv);

            // 调用拦截器的后置处理方法
			mappedHandler.applyPostHandle(processedRequest, response, mv);
		}
		catch (Exception ex) {
			dispatchException = ex;
		}

        // 处理分发返回的结果，包括了异常的处理、ModelAndView的处理
        // 以及处理拦截器链最后的afterCompetion(request, response)方法。
		processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
	}
	catch (Exception ex) {
        // 如果有异常或错误，调用HandlerInterceptor#AfterCompletion()
		triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
	}
	catch (Error err) {
		triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);
	}
	finally {
		if (asyncManager.isConcurrentHandlingStarted()) {
			mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
			return;
		}
		if (multipartRequestParsed) {
			cleanupMultipart(processedRequest);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h5 id=&#34;2-获取handlerexecutorchain对象&#34;&gt;2. 获取HandlerExecutorChain对象&lt;/h5&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在DispatchServlet中，HandlerExecutorChain对象贯穿了整个doDispatch()方法，这是一个非常重要的对象，它包含了处理对象handler和拦截器集合interceptors。HandlerInterceptor拦截器的处理都是在HandlerExecutorChain中处理的。下面是HandlerExecutorChain的属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//处理器对象
private final Object handler;
//拦截器集合
private HandlerInterceptor[] interceptors;
private List&amp;lt;HandlerInterceptor&amp;gt; interceptorList;
//执行到拦截器的索引位置
private int interceptorIndex = -1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在DispatchServlet中，调用getHandler(HttpServletRequest request)方法返回HandlerExecutionChain对象，下面看看这个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
	// 遍历HandlerMapping对象
	// handlerMappings在DispatchedServlet启动时就初始化好了，可以参考上一篇中分析
	for (HandlerMapping hm : this.handlerMappings) {
		//找到一个符合的就返回
		HandlerExecutionChain handler = hm.getHandler(request);
		if (handler != null) {
			return handler;
		}
	}
	return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
从上面可以看出，HandlerExecutionChain的创建是由HandlerMapping接口来实现的。关于HandlerMapping接口是如何创建HandlerExecutionChain对象的具体细节，在下一篇中我们详细分析。&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&#34;3-获取handleradapter对象和调用&#34;&gt;3 获取HandlerAdapter对象和调用&lt;/h6&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
HandlerAdapter接口的主要功能是：使用被给的handler对象来处理请求，然后返回ModelAndView对象。这里的handler是创建HandlerExecutionChain时就应用创建好的。handler对象可以是Controller、HandlerMethod、Servlet等，也可以是其他自定义的对象类型。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
HandlerAdapter接口提供了两个方法，方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 返回该HandlerAdapter是否支持处理给定的handler对象
 */
boolean supports(Object handler);

/**
 * 使用handler对象处理请求，调用真实的请求方法并返回ModelAndView
 */
ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
关于HandlerAdapter#handle(&amp;hellip;)方法处理请求的详细内容，我们放在后续篇章中讲解。&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&#34;4-handlerinterceptor-拦截器&#34;&gt;4.HandlerInterceptor 拦截器&lt;/h6&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
HandlerInterceptor接口提供了3个方法，方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 该方法是拦截器的前置处理方法，是在真实请求处理之前被调用。
 * 如果方法返回true，则调用拦截器链中的下一个拦截器，知道所有拦截器调用完成。
 * 如果方法返回false，则表示该请求被拦截器，请求结束。
 */
boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
    throws Exception;

/**
 * 该方法是拦截器的后置处理方法，是在真实请求之后被调用，但在试图渲染之前。
 */
void postHandle(
		HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)
		throws Exception;

/**
 * 该方法在请求处理完成之后调用，也就是说此时视图渲染已经完成。
 * 该方法通常用在清除资源。
 * 该方法可以执行的前置条件是： 拦截器链中所有的preHandle都返回true。
 * 该方法在拦截器中是反序执行的，也就是说第一个拦截器最后执行这个方法。
 */
void afterCompletion(
		HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
		throws Exception;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
关于拦截器的具体分析和SpringMVC中提供有哪些功能的拦截器，我们在后续在分篇章讲解，这里先做一个初步的认识。&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&#34;5-返回异常处理-modelandview处理&#34;&gt;5.返回异常处理、ModelAndView处理&lt;/h6&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在上面分析doDispatch()方法时，可以发现方法中对异常进行了捕获，并将捕获的异常传参到processDispatchResult()方法中去。下面我们就针对processDispatchResult()方法分析。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
		HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception {

	boolean errorView = false;
    
    // 如果发生了异常，则处理异常情况
	if (exception != null) {
	    // 如果是视图异常，则返回该ModelAndView视图
		if (exception instanceof ModelAndViewDefiningException) {
			mv = ((ModelAndViewDefiningException) exception).getModelAndView();
		}
		else {
		    // 处理异常，并返回一个异常视图
			Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
			mv = processHandlerException(request, response, handler, exception);
			errorView = (mv != null);
		}
	}

	// 处理返回的视图
	if (mv != null &amp;amp;&amp;amp; !mv.wasCleared()) {
	    // 渲染视图
		render(mv, request, response);
		if (errorView) {
			WebUtils.clearErrorRequestAttributes(request);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
通过这篇文章的分析，我们了解了SpringMVC的请求分发过程。当然，由于篇幅过长，我们还有很多细节性的东西没有分析到。相关的细节我们在后续的篇章中分析。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>SpringMVC源码分析(1) DispatchServlet初始化</title>
            <link>http://www.xiaoqiyiye.com/2015/10/21/spring/</link>
            <pubDate>Wed, 21 Oct 2015 23:43:51 &#43;0800</pubDate>
            <author>CoderZh</author>
            <guid>http://www.xiaoqiyiye.com/2015/10/21/spring/</guid>
            <description>&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
这篇文章我们来分析一下SpringMVC中DispatchServlet的启动过程。我们还是先从配置文件来看，因为配置文件会最直观地告诉我们从哪里开始分析。在使用SpringMVC时，大家都知道需要在web.xml中如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;servlet&amp;gt;
 &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
 &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
 &amp;lt;init-param&amp;gt;
 	&amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
 	&amp;lt;param-value&amp;gt;
 		classpath:applicationContext-mvc.xml
 	&amp;lt;/param-value&amp;gt;
 &amp;lt;/init-param&amp;gt;
 &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
 &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
 &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
通过如上配置，将SpringMVC的配置文件applicationContext-mvc.xml设置到DispatcherServlet中去。DispatchServlet继承了HttpServlet，因此初始化工作在init()方法中实现。DispatchServlet的继承关系为:
DispatchServlet &amp;ndash;&amp;gt; FrameworkServlet &amp;ndash;&amp;gt; HttpServletBean &amp;ndash;&amp;gt; HttpServlet。下面我们进入到HttpServletBean#init()方法看看初始化的过程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final void init() throws ServletException {

	try {
        
        //获取Servlet参数，将信息都存放到BeanWrapper这个对象中去
		PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);
		BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);
		ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());
		bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));
		
		//这是一个钩子方法，子类可以去处理BeanWrapper对象
        initBeanWrapper(bw);
		bw.setPropertyValues(pvs, true);
	}
	catch (BeansException ex) {
		logger.error(&amp;quot;Failed to set bean properties on servlet &#39;&amp;quot; + getServletName() + &amp;quot;&#39;&amp;quot;, ex);
		throw ex;
	}

	// 真正的初始化让子类去完成，也就是FrameworkServlet类
	initServletBean();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
接下来，跟踪到FrameworkServlet#initServletBean()，这个方法没什么好说的，就一句重要的代码，initWebApplicationContext()这个方法。这个方法去初始化Spring容器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected final void initServletBean() throws ServletException {
	try {
        // 初始化Spring容器
		this.webApplicationContext = initWebApplicationContext();
		// 钩子方法，可以在容器加载完后，做一些初始化操作。
        initFrameworkServlet();
	}
	catch (ServletException ex) {
		throw ex;
	}
	catch (RuntimeException ex) {
		throw ex;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
那么，我们去看看容器是怎么初始化的？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected WebApplicationContext initWebApplicationContext() {

    // 还记得SpringWeb容器吗
    // 这里就是去获取SpringWeb容器当作根容器，把它作为SpringMVC的父容器
	WebApplicationContext rootContext =
			WebApplicationContextUtils.getWebApplicationContext(getServletContext());
			
	WebApplicationContext wac = null;

    // 如果使用了带webApplicationContext参数的构造方法，就调用这里，
    // 设置父类容器并刷新启动（以上XML配置情况不会执行这里）
	if (this.webApplicationContext != null) {
		wac = this.webApplicationContext;
		if (wac instanceof ConfigurableWebApplicationContext) {
			ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;
			if (!cwac.isActive()) {
				if (cwac.getParent() == null) {
					cwac.setParent(rootContext);
				}
				configureAndRefreshWebApplicationContext(cwac);
			}
		}
	}

    // 从ServletContext中找，看是否有容器存在
	if (wac == null) {
		wac = findWebApplicationContext();
	}
    
    // 如果没有找到，则去创建一个新的容器，并设置rootContext为父容器
	if (wac == null) {
	    // 这里会启动容器
		wac = createWebApplicationContext(rootContext);
	}

    // 判断是否已经触发过监听器，如果没有则会调用onRefresh(wac)
    // 否则，表示容器已经启动过，refreshEventReceived=true，不会再调用。         
    // 具体细节可查看FrameworkServlet内部类ContextRefreshListener。
    // onRefresh(wac)是一个钩子方法，具体实现是在DispatcherServlet中实现的
    // 这个方法主要初始化了一系列的SpringMVC相关对象（策略对象）
	if (!this.refreshEventReceived) {
		onRefresh(wac);
	}

    // 把新的容器作为属性设置到ServletContext中
    // attrName属性key为&amp;quot;FrameworkServlet.CONTEXT.&amp;quot; + servletName
	if (this.publishContext) {
		String attrName = getServletContextAttributeName();
		getServletContext().setAttribute(attrName, wac);
	}

	return wac;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
到目前为止，我们还没有看看容器真正启动，启动是在createWebApplicationContext(rootContext)中完成的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected WebApplicationContext createWebApplicationContext(ApplicationContext parent) {

    // 获取容器的类型，可以在web.xml中设置contextClass参数配置
	Class&amp;lt;?&amp;gt; contextClass = getContextClass();

    // 实例化容器对象
	ConfigurableWebApplicationContext wac =
			(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);

	wac.setEnvironment(getEnvironment());
	
    // 设置Spring Web容器作为父容器
	wac.setParent(parent);
    // 设置在web.xml中配置的applicationContext-mvc.xml配置文件
	wac.setConfigLocation(getContextConfigLocation());

    // 开始启动容器
	configureAndRefreshWebApplicationContext(wac);

	return wac;
}

protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) {
    
    // 设置Servlet相关信息
	wac.setServletContext(getServletContext());
	wac.setServletConfig(getServletConfig());
	wac.setNamespace(getNamespace());

    // 添加容器监听器
	wac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener()));

	// 这是一个钩子方法，负责context的后置处理，其实和下面的applyInitializers(wac)一样
	postProcessWebApplicationContext(wac);

    // 在容器启动前，可以自定义容器初始化，配置参数contextInitializerClasses可以实现，只能配置ApplicationContextInitializer实现类，这个和Spring Web启动时一样，参见ContextLoaderListener。
	applyInitializers(wac);

    // 启动容器
	wac.refresh();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
到目前为止，Dispatcher的初始化已经分析的差不多了，和前面分析的SpringMVC容器启动基本上相似。上面提到了onRefresh(wac)方法，这个方法是初始化的尾声了，看看onRefresh(wac)方法做了什么事情，怎么把我们带进SpringMVC的世界呢？&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在onRefresh(wac)中就调用了initStrategies(context)，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void initStrategies(ApplicationContext context) {
	initMultipartResolver(context);
	initLocaleResolver(context);
	initThemeResolver(context);
	initHandlerMappings(context);
	initHandlerAdapters(context);
	initHandlerExceptionResolvers(context);
	initRequestToViewNameTranslator(context);
	initViewResolvers(context);
	initFlashMapManager(context);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
看到上面的代码，似乎让我们熟悉起来，这些都是SpringMVC中关键的接口。上面的初始化方法处理的方式都很相似，这里就不一一分析了，分析下initHanderMappings(context)就可以了，只需明白在DispatcherServlet开始处理请求分发时，这些对象都已经初始化好了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void initHandlerMappings(ApplicationContext context) {
	this.handlerMappings = null;

    // 是否检测所有的HandlerMapping（也会去父容器检测）
    // 也就是说检测我们是否在配置文件中配置了HandlerMapping接口的Bean
	if (this.detectAllHandlerMappings) {
		Map&amp;lt;String, HandlerMapping&amp;gt; matchingBeans =
				BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);
		if (!matchingBeans.isEmpty()) {
			this.handlerMappings = new ArrayList&amp;lt;HandlerMapping&amp;gt;(matchingBeans.values());
			// 排序
			OrderComparator.sort(this.handlerMappings);
		}
	}
	else {
		try {
            // 只检测一个HandlerMapping，根据默认handlerMapping的Bean名称去查找。
			HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);
			this.handlerMappings = Collections.singletonList(hm);
		}
		catch (NoSuchBeanDefinitionException ex) {
		}
	}

    // 如果还是没有检测到，则确保有一个默认的HandlerMapping存在，
    // 这个默认的HandlerMapping是BeanNameUrlHandlerMapping，
    // SpringMVC的默认策略是配置在DispatcherServlet.properties属性文件中。
	if (this.handlerMappings == null) {
		this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
这样SpringMVC中的HandlerMapping接口实现类就已经初始化好了，其他接口的初始化处理过程也是类似的，就不一一分析了。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
关于默认的配置文件DispatcherServlet.properties，提供了8个接口的默认类型。DispatcherServlet.properties文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver

org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver

org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\
	org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping

org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\
	org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\
	org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter

org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\
	org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\
	org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver

org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator

org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver

org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
关于DispatchServlet启动过程就分析到这里，总结一下DispatchServlet的流程：
1. 创建容器对象
2. 启动容器对象(前两步流程和SpringWEB的启动一样的)
3. 初始化SpringMVC相关联的一些策略接口&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
通过对这篇文章的了解，只是可以启动SpringMVC了，为接下来的SpringMVC使用做准备。但是SpringMVC到底是如何处理请求的呢？这个问题我们在后面的篇章中会分析到。DispatchServlet的核心部分，处理请求分发过程。&lt;/p&gt;
</description>
        </item>
        
        <item>
            <title>SpringWeb源码分析(1) Web容器启动</title>
            <link>http://www.xiaoqiyiye.com/2015/10/18/spring/</link>
            <pubDate>Sun, 18 Oct 2015 23:43:51 &#43;0800</pubDate>
            <author>CoderZh</author>
            <guid>http://www.xiaoqiyiye.com/2015/10/18/spring/</guid>
            <description>

&lt;hr /&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在分析SpringMVC之前先了解一下Spring Web容器的加载过程，看看在Web容器中Spring是如何加载的。在web.xml配置文件中我们常常会配置如下代码。代码中配置了contextConfigLocation和ContextLoaderListenter，contextConfigLocation用来设置Spring的配置文件，ContextLoaderListenter用来启动Spring Web容器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;context-param&amp;gt;
  &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
  &amp;lt;param-value&amp;gt;classpath:applicationContext.xml&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;

&amp;lt;listener&amp;gt;
  &amp;lt;listener-class&amp;gt;
  	org.springframework.web.context.ContextLoaderListener
  &amp;lt;/listener-class&amp;gt;
&amp;lt;/listener&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;spring-web容器的初始化&#34;&gt;Spring Web容器的初始化&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
从上面的配置，可想而知ContextLoaderListener是分析的入口，ContextLoaderListener实现了ServletContextListener接口，ServletContextListener是Java Servlet的API，其负责监听Servlet的生命周期。在ServletContextListener中存在一个contextInitialized(ServletContextEvent sce)方法，当Web应用开启时后调用此方法。&lt;/p&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
那我们看看ContextLoaderListener#contextInitialized(ServletContextEvent sce)方法，其实这个方法就调用了父类的ContextLoader#initWebApplicationContext(ServletContext servletContext)。我们接下来分析initWebApplicationContext(ServletContext servletContext)方法的源码，方法中最重要的就是如何生成context实例，也就是creatWebApplicationContext(servletContext)这个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {

    // 判断是否已经加载过，如果已经加载，则抛出异常。
	if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {
		throw new IllegalStateException();
	}

	Log logger = LogFactory.getLog(ContextLoader.class);
	servletContext.log(&amp;quot;Initializing Spring root WebApplicationContext&amp;quot;);
	
	long startTime = System.currentTimeMillis();

	try {

		if (this.context == null) {
            // 创建Spring Web容器 WebApplicationContext
			this.context = createWebApplicationContext(servletContext);
		}
		if (this.context instanceof ConfigurableWebApplicationContext) {
			ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;
			if (!cwac.isActive()) {
				// 如果没有父类容器，则设置父类容器
				if (cwac.getParent() == null) {
					ApplicationContext parent = loadParentContext(servletContext);
					cwac.setParent(parent);
				}
                // 刷新容器
				configureAndRefreshWebApplicationContext(cwac, servletContext);
			}
		}
		
        // 设置到Servlet的上下文属性中去，以便后续业务中可以获取
		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);

        // 关联当前Spring Web容器和类加载器Map，便于外部获取当前类加载器关联的Spring Web容器
		ClassLoader ccl = Thread.currentThread().getContextClassLoader();
		if (ccl == ContextLoader.class.getClassLoader()) {
			currentContext = this.context;
		}
		else if (ccl != null) {
			currentContextPerThread.put(ccl, this.context);
		}

        // 返回当前的Spring Web容器对象
		return this.context;
	}
	catch (RuntimeException ex) {
		logger.error(&amp;quot;Context initialization failed&amp;quot;, ex);
		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);
		throw ex;
	}
	catch (Error err) {
		logger.error(&amp;quot;Context initialization failed&amp;quot;, err);
		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);
		throw err;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;spring-web容器的实例化&#34;&gt;Spring Web容器的实例化&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
在上面有看到创建context是在createWebApplicationContext(servletContext)中，这个方法很简单，获取到容器的类型后通过反射实例化。 这个方法源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected WebApplicationContext createWebApplicationContext(ServletContext sc) {

    // 获取容器的类型，默认为XmlWebApplicationContext
	Class&amp;lt;?&amp;gt; contextClass = determineContextClass(sc);
	
	// 如果类型错误，则会抛出异常
	if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {
		throw new ApplicationContextException();
	}
	
	// 反射实例化一个Spring Web容器对象
	return (ConfigurableWebApplicationContext)BeanUtils.instantiateClass(contextClass);
}

protected Class&amp;lt;?&amp;gt; determineContextClass(ServletContext servletContext) {

    // 首先，从web.xml中获取classContext属性，如果配置了这个属性，则根据配置来设置类型。
	String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);
	if (contextClassName != null) {
		try {
			return ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());
		}
		catch (ClassNotFoundException ex) {
			throw new ApplicationContextException(
					&amp;quot;Failed to load custom context class [&amp;quot; + contextClassName + &amp;quot;]&amp;quot;, ex);
		}
	}
	// 否则，从Spring包提供的ContextLoader.properties中去找，Spring提供的默认类型是XmlWebApplicationContext。
	else {
		contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());
		try {
			return ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());
		}
		catch (ClassNotFoundException ex) {
			throw new ApplicationContextException(
					&amp;quot;Failed to load default context class [&amp;quot; + contextClassName + &amp;quot;]&amp;quot;, ex);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
Spring提供的默认容器类型为XmlWebApplicationContext，但是这个值是可以设置的，在web.xml中可以配置classContext来实现，但是这个值必须是ConfigurableWebApplicationContext的子类，否则会抛异常。配置方式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;context-param&amp;gt;
  	&amp;lt;param-name&amp;gt;classContext&amp;lt;/param-name&amp;gt;
  	&amp;lt;param-value&amp;gt;org.springframework.web.context.XmlWebAlpplicationContext&amp;lt;/param-value&amp;gt;
  &amp;lt;/context-param&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
从上面的分析看，只是实例化了容器对象，但是Spring容器还没有启动，在web.xml中配置的contextConfigLocation也没有被加载。接下来看看，Spring容器的加载。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;spring-web容器的加载&#34;&gt;Spring Web容器的加载&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
我们还是回到initWebApplicationContext(ServletContext servletContext)方法中， 看看configureAndRefreshWebApplicationContext(cwac, servletContext)这句代码。不要怀疑能否可以进入if语句，createWebApplicationContext()方法返回的类型肯定是ConfigurableWebApplicationContext。看看容器是如何加载的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {

    // 生成容器Id
	if (ObjectUtils.identityToString(wac).equals(wac.getId())) {
		String idParam = sc.getInitParameter(CONTEXT_ID_PARAM);
		if (idParam != null) {
			wac.setId(idParam);
		}
		else {
			wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +
					ObjectUtils.getDisplayString(sc.getContextPath()));
		}
	}

    // 设置ServletContext上下文对象
	wac.setServletContext(sc);
	
    // 获取Spring配置文件，在web.xml中配置的contextConfigLocation参数。对于XmlWebApplicationContext默认值为/WEB-INF/applicationContext.xml
	String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);
	if (configLocationParam != null) {
		wac.setConfigLocation(configLocationParam);
	}

	// 提前初始化环境属性，确保容器刷新时post-processing或initialization等相关的接口使用
	ConfigurableEnvironment env = wac.getEnvironment();
	if (env instanceof ConfigurableWebEnvironment) {
		((ConfigurableWebEnvironment) env).initPropertySources(sc, null);
	}

    // 在启动容器前，还可以自定义容器
	customizeContext(sc, wac);
	
    // Spring WEB容器启动
	wac.refresh();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;自定义容器&#34;&gt;自定义容器&lt;/h3&gt;

&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
Spring Web容器启动前可以进行一些自定义，通过ApplicationContextInitializer接口来完成。在web.xml中可以配置globalInitializerClasses和contextInitializerClasses这两个参数来实现自定义容器，当然配置的类需要是ApplicationContextInitializer接口的实现类。另外，实现Ordered接口或@Order注解，可以进行排序。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;globalInitializerClasses&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;XxxApplicationContextInitializer&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;
&amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;contextInitializerClasses&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;XxxApplicationContextInitializer&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单的看一下customizeContext(sc, wac)这个方法，源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void customizeContext(ServletContext sc, ConfigurableWebApplicationContext wac) {

    // 找到配置的globalInitializerClasses和contextInitializerClasses
	List&amp;lt;Class&amp;lt;ApplicationContextInitializer&amp;lt;ConfigurableApplicationContext&amp;gt;&amp;gt;&amp;gt; initializerClasses = determineContextInitializerClasses(sc);
	if (initializerClasses.isEmpty()) {
		return;
	}

	ArrayList&amp;lt;ApplicationContextInitializer&amp;lt;ConfigurableApplicationContext&amp;gt;&amp;gt; initializerInstances =
			new ArrayList&amp;lt;ApplicationContextInitializer&amp;lt;ConfigurableApplicationContext&amp;gt;&amp;gt;();

    // 反射实例化
	for (Class&amp;lt;ApplicationContextInitializer&amp;lt;ConfigurableApplicationContext&amp;gt;&amp;gt; initializerClass : initializerClasses) {
		initializerInstances.add(BeanUtils.instantiateClass(initializerClass));
	}

    // 按照Ordered接口或@Order注解排序
	AnnotationAwareOrderComparator.sort(initializerInstances);

    // 遍历调用initialize方法
	for (ApplicationContextInitializer&amp;lt;ConfigurableApplicationContext&amp;gt; initializer : initializerInstances) {
		initializer.initialize(wac);
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        
    </channel>
</rss>
